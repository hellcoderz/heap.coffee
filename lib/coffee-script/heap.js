// Generated by CoffeeScript 1.3.1
(function() {
  var ArrowType, Assign, Base, Code, DeclareType, Deref, Literal, Op, PointerType, PrimitiveType, Ref, Scope, StructType, TypeAssign, TypeName, Value, charTy, closeSynonyms, extend, flatten, intTy, nullTy, primitiveTypes, shortTy, uintTy, unify, _ref, _ref1,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Scope = require('./scope').Scope;

  _ref = require('./nodes'), Base = _ref.Base, Value = _ref.Value, Literal = _ref.Literal, Op = _ref.Op, Assign = _ref.Assign, Code = _ref.Code, TypeAssign = _ref.TypeAssign, DeclareType = _ref.DeclareType, Ref = _ref.Ref, Deref = _ref.Deref, TypeName = _ref.TypeName, PointerType = _ref.PointerType, ArrowType = _ref.ArrowType, StructType = _ref.StructType;

  _ref1 = require('./helpers'), flatten = _ref1.flatten, extend = _ref1.extend;

  Scope.prototype.findTyped = function(name, type, options) {
    if (this.check(name, options)) {
      return true;
    }
    this.add(name, type);
    return false;
  };

  Scope.prototype.typeOf = function(name, immediate) {
    var found, _ref2;
    found = this.type(name);
    if (found || immediate) {
      return found;
    }
    return (_ref2 = this.parent) != null ? _ref2.typeOf(name) : void 0;
  };

  Base.prototype.foldChildren = function(r, m, o) {
    var attr, child, _i, _j, _len, _len1, _ref2, _ref3;
    if (!this.children) {
      return r;
    }
    _ref2 = this.children;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      attr = _ref2[_i];
      if (this[attr]) {
        _ref3 = flatten([this[attr]]);
        for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
          child = _ref3[_j];
          r = (o != null ? o.immediate : void 0) ? (typeof child[m] === "function" ? child[m](r, o) : void 0) || r : child.foldChildren((typeof child[m] === "function" ? child[m](r, o) : void 0) || r, m, o);
        }
      }
    }
    return r;
  };

  Code.prototype.foldChildren = function(r, m, o) {
    if (!(o != null ? o.crossScope : void 0)) {
      return r;
    }
    return Code.__super__.foldChildren.call(this, r, m, extend({}, o));
  };

  TypeAssign.prototype.collectType = function(types) {
    types[this.name] = this.type;
    return types;
  };

  Code.prototype.buildTypedScope = function(r, o) {
    this.typedScope = o.scope = new Scope(o.scope, this.body, this);
  };

  DeclareType.prototype.buildTypedScope = function(r, o) {
    this.type.lint(o.types);
    o.scope.findTyped(this.variable.unwrapAll().value, this.type);
  };

  Code.prototype.propagateArgType = function(r, o) {
    o.scope = this.typedScope;
  };

  Assign.prototype.propagateArgType = function(r, o) {
    var fn, fnScope, i, name, paramTys, pname, ty, _i, _len, _ref2;
    if ((fn = this.value.unwrapAll()) instanceof Code && (name = this.variable.unwrapAll()) instanceof Literal && name.isAssignable()) {
      if ((ty = o.scope.typeOf(name.value)) instanceof ArrowType) {
        fnScope = fn.typedScope;
        paramTys = ty.params;
        _ref2 = fn.params;
        for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {
          pname = _ref2[i].name;
          if (paramTys[i]) {
            if (pname instanceof Literal) {
              fnScope.findTyped(pname.value, paramTys[i]);
            }
          }
        }
      }
    }
  };

  TypeName.prototype.resolve = function(types) {
    var ty;
    ty = types[this.name];
    if (!ty) {
      throw new Error("cannot resolve type `" + this.name + "'");
    }
    return ty;
  };

  PointerType.prototype.resolve = function(types) {
    return this;
  };

  StructType.prototype.resolve = function(types) {
    return this;
  };

  ArrowType.prototype.resolve = function(types) {
    return this;
  };

  TypeName.prototype.lint = function(types) {
    var ty;
    if (this.linted) {
      return;
    }
    this.linted = true;
    ty = this.resolve(types);
    return ty.lint(types);
  };

  PointerType.prototype.size = 4;

  PointerType.prototype.lint = function(types) {
    if (this.linted) {
      return;
    }
    this.linted = true;
    if (this.base.resolve(types) instanceof ArrowType) {
      throw new Error("cannot take pointers of function types");
    }
    return this.base.lint(types);
  };

  StructType.prototype.lint = function(types) {
    var size, ty, _i, _j, _len, _len1, _ref2, _ref3;
    if (this.linted) {
      return;
    }
    this.linted = true;
    _ref2 = this.fields;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      ty = _ref2[_i].type;
      ty.lint(types);
    }
    size = 0;
    _ref3 = this.fields;
    for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
      ty = _ref3[_j].type;
      size += ty.size;
    }
    return this.size = size;
  };

  ArrowType.prototype.lint = function(types) {
    var ty, _i, _len, _ref2, _results;
    if (this.linted) {
      return;
    }
    this.linted = true;
    _ref2 = this.params.concat([this.ret]);
    _results = [];
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      ty = _ref2[_i];
      if (ty.resolve(types) instanceof ArrowType) {
        throw new Error("cannot type higher-order functions");
      }
      _results.push(ty.lint(types));
    }
    return _results;
  };

  unify = function(types, ty1, ty2) {
    var base, ty1r, ty2r;
    ty1r = ty1.resolve(types);
    ty2r = ty2.resolve(types);
    if (ty1r === ty2r) {
      return ty1r;
    }
    if (ty1r instanceof PointerType && ty2r === nullTy) {
      return ty1r;
    }
    if (ty2r instanceof PointerType && ty1r === nullTy) {
      return ty2r;
    }
    if (ty1r instanceof PointerType && ty2r instanceof PointerType) {
      base = unify(types, ty1r.base, ty2r.base);
      if (base) {
        return new PointerType(base);
      }
    }
    return null;
  };

  Base.prototype.computeType = function(types, scope) {};

  Literal.prototype.computeType = function(types, scope) {
    var _ref2;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    return this.computedType = this.isAssignable() ? (_ref2 = scope.typeOf(this.value)) != null ? _ref2.resolve(types) : void 0 : this.value === 'null' ? nullTy : this.isSimpleNumber() ? intTy : void 0;
  };

  Value.prototype.computeType = function(types, scope) {
    var baseTy, fieldName, prop, props, _i, _len;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    if (this.base instanceof Literal && this.base.isAssignable()) {
      baseTy = this.base.computeType(types, scope);
      props = this.properties;
      for (_i = 0, _len = props.length; _i < _len; _i++) {
        prop = props[_i];
        if (baseTy instanceof PointerType) {
          baseTy = baseTy.base.resolve(types);
        }
        if (!(baseTy instanceof StructType)) {
          return;
        }
        if (prop.soak) {
          throw new Error("cannot soak field names");
        }
        fieldName = prop.name.unwrapAll().value;
        baseTy = baseTy.typeOf[fieldName];
        if (!baseTy) {
          throw new Error("unknown struct field name `" + fieldName + "'");
        }
      }
      return this.computedType = baseTy;
    }
  };

  Op.prototype.computeType = function(types, scope) {
    var ARITH_OPS, op, primTys, ty1, ty2;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    if (this.isUnary()) {
      return (this.computedType = void 0);
    }
    op = this.operator;
    ty1 = this.first.unwrapAll().computeType(types, scope);
    ty2 = this.second.unwrapAll().computeType(types, scope);
    ARITH_OPS = ['+', '-', '*', '/', '<<', '>>', '>>>', '~', '&', '|'];
    primTys = [charTy, shortTy, intTy, uintTy];
    return this.computedType = op === '+' && ty1 instanceof PointerType && ty2 === intTy ? ty1 : op === '-' && ty1 instanceof PointerType && ty2 instanceof PointerType ? unify(types, ty1.base, ty2.base) : __indexOf.call(ARITH_OPS, op) >= 0 && __indexOf.call(primTys, ty1) >= 0 && __indexOf.call(primTys, ty2) >= 0 ? intTy : void 0;
  };

  Ref.prototype.computeType = function(types, scope) {
    var ty;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    ty = this.expr.unwrapAll().computeType(types, scope);
    if (ty) {
      return this.computedType = new PointerType(ty);
    }
  };

  Deref.prototype.computeType = function(types, scope) {
    var ty;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    ty = this.expr.unwrapAll().computeType(types, scope);
    if (ty instanceof PointerType) {
      return this.computedType = ty.base;
    }
  };

  Code.prototype.typecheck = function(r, o) {
    return o.scope = this.typedScope;
  };

  Value.prototype.typecheck = function(r, o) {
    return this.computeType(o.type, o.scope);
  };

  Ref.prototype.typecheck = function(r, o) {
    var ty;
    ty = this.computeType(o.type, o.scope);
    if (!ty) {
      throw new Error("taking reference of an untyped expression:\n" + this.expr);
    }
    if (ty instanceof ArrowType) {
      throw new Error("taking reference of a function type");
    }
  };

  Deref.prototype.typecheck = function(r, o) {
    var ty;
    ty = this.computeType(o.types, o.scope);
    if (!ty) {
      throw new Error("dereferencing an untyped expression:\n" + this.expr);
    }
    if (!(ty instanceof PointerType)) {
      throw new Error("dereferencing a non-pointer type");
    }
  };

  Assign.prototype.typecheck = function(r, o) {
    var lhTy, rhTy, scope, types;
    types = o.types;
    scope = o.scope;
    lhTy = this.variable.unwrapAll().computeType(types, scope);
    rhTy = this.value.unwrapAll().computeType(types, scope);
    if (lhTy && rhTy && !unify(types, lhTy, rhTy)) {
      throw new Error("incompatible types in assignment: `" + lhTy + "' and `" + rhTy + "'");
    }
  };

  closeSynonyms = function(types) {
    var name, ty;
    for (name in types) {
      ty = types[name];
      while (ty instanceof TypeName) {
        ty = ty.resolve(types);
      }
      types[name] = ty;
    }
  };

  PrimitiveType = (function() {

    function PrimitiveType(size, name) {
      this.size = size;
      this.name = name;
    }

    PrimitiveType.prototype.resolve = function(types) {
      return this;
    };

    PrimitiveType.prototype.lint = function(types) {};

    PrimitiveType.prototype.toString = function() {
      return this.name;
    };

    return PrimitiveType;

  })();

  nullTy = new PrimitiveType(0, 'null');

  charTy = new PrimitiveType(1, 'char');

  shortTy = new PrimitiveType(2, 'short');

  intTy = new PrimitiveType(4, 'int');

  uintTy = new PrimitiveType(4, 'uint');

  primitiveTypes = {
    char: charTy,
    short: shortTy,
    int: intTy,
    uint: uintTy
  };

  exports.analyzeTypes = function(root) {
    var o, scope, types;
    types = root.foldChildren(primitiveTypes, 'collectType', {
      immediate: true
    });
    closeSynonyms(types);
    root.typedScope = scope = new Scope(null, root, null);
    o = {
      types: types,
      scope: scope,
      crossScope: true
    };
    root.foldChildren(null, 'buildTypedScope', o);
    root.foldChildren(null, 'propagateArgType', o);
    root.foldChildren(null, 'typecheck', o);
    return types;
    console.log("Types:");
    console.log(types);
    console.log("Type Scope Toplevel:");
    console.log(root.typedScope.variables);
    return root.traverseChildren(true, function(n) {
      if (n instanceof Code) {
        return console.log(n.typedScope.variables);
      }
    });
  };

}).call(this);
