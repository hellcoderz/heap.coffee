// Generated by CoffeeScript 1.3.1
(function() {
  var ARITH, Access, Arr, ArrowType, Assign, BITWISE, Base, Binding, Block, COMPARE, Call, Cast, Code, Comment, DeclareType, F32, F64, FREE, FreshLiteral, HEAP, I16, I32, I8, If, Index, Literal, MALLOC, MEMCPY, Obj, Op, Param, Parens, PointerType, PrimitiveType, Return, SP, SPREAL, Scope, StructType, Switch, Try, TypeArr, TypeAssign, TypeName, TypeObj, TypeObjField, U16, U32, U8, Value, ViewLiteral, While, alignOffset, alignmentUnits, anyPtrTy, binopType, cast, coerceIntegral, collectReturns, declare, error, extend, f64ty, flatten, i16ty, i32ty, i8ty, inlineMemcpy, integral, last, lastNonCommentOrDecl, makeDeref, multExpr, newTypedScope, normalizePtr, numeric, offsetExpr, opts, printWarn, putOnStack, requireExpr, stackFence, stackOffsetExpr, typeTransformArray, tystr, u16ty, u32ty, u8ty, undefExpr, unify, unit, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Scope = require('./scope').Scope;

  _ref = require('./nodes'), Base = _ref.Base, Parens = _ref.Parens, Block = _ref.Block, Value = _ref.Value, Literal = _ref.Literal, Op = _ref.Op, Assign = _ref.Assign, Try = _ref.Try, If = _ref.If, Switch = _ref.Switch, Param = _ref.Param, Code = _ref.Code, Index = _ref.Index, Access = _ref.Access, Call = _ref.Call, Return = _ref.Return, Obj = _ref.Obj, While = _ref.While, Comment = _ref.Comment, Arr = _ref.Arr, Obj = _ref.Obj, TypeAssign = _ref.TypeAssign, DeclareType = _ref.DeclareType, Cast = _ref.Cast, TypeArr = _ref.TypeArr, TypeObj = _ref.TypeObj, TypeObjField = _ref.TypeObjField, TypeName = _ref.TypeName, PointerType = _ref.PointerType, ArrowType = _ref.ArrowType, StructType = _ref.StructType;

  _ref1 = require('./helpers'), flatten = _ref1.flatten, last = _ref1.last, extend = _ref1.extend, tystr = _ref1.tystr;

  error = function(node, msg) {
    var err;
    err = new TypeError(msg);
    err.lineno = node.lineno;
    throw err;
  };

  HEAP = new Value(new Literal('_HEAP'));

  ViewLiteral = (function(_super) {

    __extends(ViewLiteral, _super);

    function ViewLiteral(value, BYTES_PER_ELEMENT) {
      this.value = value;
      this.BYTES_PER_ELEMENT = BYTES_PER_ELEMENT;
    }

    ViewLiteral.prototype.compileNode = function(o) {
      var name;
      name = this.value;
      o.scope.assign(name, "" + HEAP.base.value + "." + (name.substr(name.lastIndexOf('_') + 1)));
      return ViewLiteral.__super__.compileNode.call(this, o);
    };

    return ViewLiteral;

  })(Literal);

  I8 = new ViewLiteral('_I8', 1);

  U8 = new ViewLiteral('_U8', 1);

  I16 = new ViewLiteral('_I16', 2);

  U16 = new ViewLiteral('_U16', 2);

  I32 = new ViewLiteral('_I32', 4);

  U32 = new ViewLiteral('_U32', 4);

  F32 = new ViewLiteral('_F32', 4);

  F64 = new ViewLiteral('_F64', 8);

  SP = new Value(new Literal('_SP'));

  SPREAL = new Value(U32, [new Index(new Value(new Literal(1)))]);

  MALLOC = new Value(new Literal('malloc'));

  FREE = new Value(new Literal('free'));

  MEMCPY = new Value(new Literal('memcpy'));

  opts = {
    warn: false,
    unsafe: false
  };

  printWarn = function(line) {
    if (opts.warn) {
      return process.stderr.write('warning: ' + line + '\n');
    }
  };

  FreshLiteral = (function(_super) {

    __extends(FreshLiteral, _super);

    function FreshLiteral(value, type) {
      this.value = value;
      this.type = type;
    }

    FreshLiteral.prototype.compileNode = function(o) {
      this.value = o.scope.freeVariable(this.value);
      this.compileNode = Literal.prototype.compileNode;
      return FreshLiteral.__super__.compileNode.call(this, o);
    };

    FreshLiteral.prototype.typeTransformNode = function(o) {
      return this;
    };

    return FreshLiteral;

  })(Literal);

  normalizePtr = function(ptr, lalign, ralign) {
    var inner, op, ratio;
    if (lalign === ralign || ((inner = ptr.unwrapAll()) instanceof Literal && inner.value === '0' || inner.value === 'null')) {
      return ptr;
    }
    if (lalign < ralign) {
      ratio = ralign / lalign;
      op = '>>';
    } else {
      ratio = lalign / ralign;
      op = '<<';
    }
    return new Parens(new Op(op, ptr, new Value(new Literal(Math.log(ratio) / Math.log(2)))));
  };

  offsetExpr = function(base, baseTy, offset, offsetTy) {
    var balign, normalized, oalign;
    balign = baseTy.view.BYTES_PER_ELEMENT;
    oalign = offsetTy.view.BYTES_PER_ELEMENT;
    normalized = normalizePtr(base, balign, oalign);
    if (offset !== 0) {
      return new Op('+', normalized, new Value(new Literal(offset / oalign)));
    } else {
      return normalized;
    }
  };

  stackOffsetExpr = function(o, offset, offsetTy) {
    return offsetExpr(SP, i32ty, offset, offsetTy);
  };

  multExpr = function(base, size) {
    if (size && ((size & (size - 1)) === 0)) {
      return new Parens(new Op('<<', base, new Value(new Literal(Math.log(size) / Math.log(2)))));
    } else {
      return new Op('*', base, new Value(new Literal(size)));
    }
  };

  stackFence = function(o, exprs, frameSize, isRoot) {
    var restoreStack, t;
    t = new Assign(SP, normalizePtr(SPREAL, U8.BYTES_PER_ELEMENT, I32.BYTES_PER_ELEMENT));
    exprs.unshift(new Assign(SP, normalizePtr(SPREAL, U8.BYTES_PER_ELEMENT, I32.BYTES_PER_ELEMENT)));
    exprs.unshift(new Assign(SPREAL, new Value(new Literal(frameSize)), '-='));
    restoreStack = new Assign(SPREAL, new Value(new Literal(frameSize)), '+=');
    if (opts.unsafe) {
      if (isRoot) {
        exprs.push(restoreStack);
      }
    } else {
      exprs[0] = new Try(new Block(exprs.slice()), null, null, new Block([restoreStack]));
      exprs.length = 1;
    }
  };

  coerceIntegral = function(width, signed) {
    return function(expr, ty) {
      var c, shiftBy, tywidth;
      if (ty === this) {
        return expr;
      }
      tywidth = ty.size << 3;
      if (width !== 32 && tywidth > width) {
        c = new Op('&', expr, new Value(new Literal('0x' + ((1 << width) - 1).toString(16))));
        if (signed) {
          shiftBy = new Value(new Literal(32 - width));
          c = new Op('>>', new Op('<<', c, shiftBy), shiftBy);
        }
        return c;
      } else if (width !== tywidth || ty.signed !== signed) {
        return new Op((signed ? '|' : '>>>'), expr, new Value(new Literal('0')));
      } else {
        return expr;
      }
    };
  };

  makeDeref = function(o, base, baseTy, offset, offsetTy) {
    return new Value(offsetTy.view, [new Index(offsetExpr(base, baseTy, offset, offsetTy))]);
  };

  inlineMemcpy = function(o, dest, src, ty) {
    var align, destPtr, i, srcPtr, stmts, _i, _ref2;
    stmts = [];
    destPtr = new Value(new FreshLiteral('dest'));
    stmts.push(new Assign(destPtr, dest));
    srcPtr = new Value(new FreshLiteral('src'));
    stmts.push(new Assign(new Value(srcPtr), src));
    align = ty.view.BYTES_PER_ELEMENT;
    for (i = _i = 0, _ref2 = alignmentUnits(ty); 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
      stmts.push(new Assign(makeDeref(o, destPtr, ty, i * align, ty), makeDeref(o, srcPtr, ty, i * align, ty)));
    }
    stmts.push(new Value(destPtr));
    return new Value(new Parens(new Block(stmts)));
  };

  lastNonCommentOrDecl = function(list) {
    var i;
    i = list.length;
    while (i--) {
      if (!(list[i] instanceof Comment) && !(list[i] instanceof TypeAssign) && !(list[i] instanceof DeclareType)) {
        return [list[i], i];
      }
    }
    return null;
  };

  Base.prototype.foldChildren = function(r, m, o) {
    var attr, child, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref2, _ref3, _ref4, _ref5;
    if (!this.children) {
      return r;
    }
    if (o.immediate) {
      _ref2 = this.children;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        attr = _ref2[_i];
        if (this[attr]) {
          _ref3 = flatten([this[attr]]);
          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
            child = _ref3[_j];
            r = typeof child[m] === 'function' ? child[m](r, o) : r;
          }
        }
      }
    } else {
      _ref4 = this.children;
      for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
        attr = _ref4[_k];
        if (this[attr]) {
          _ref5 = flatten([this[attr]]);
          for (_l = 0, _len3 = _ref5.length; _l < _len3; _l++) {
            child = _ref5[_l];
            r = child.foldChildren(r, m, o);
          }
        }
      }
    }
    if (typeof this[m] === 'function') {
      return this[m](r, o);
    } else {
      return r;
    }
  };

  Code.prototype.foldChildren = function(r, m, o) {
    if (!o.crossScope) {
      return r;
    }
    return Code.__super__.foldChildren.call(this, r, m, o);
  };

  collectReturns = function(body) {
    var exprs;
    exprs = body.expressions;
    return body.foldChildren([], 'collectReturn', {});
  };

  undefExpr = new Value(new Literal('undefined'));

  Return.prototype.collectReturn = function(exprs, o) {
    exprs.push(this);
    return exprs;
  };

  Binding = (function() {

    function Binding(type) {
      this.type = type;
    }

    return Binding;

  })();

  Scope.prototype.binding = function(name, immediate) {
    var found, _ref2;
    found = this.type(name);
    if (found || immediate) {
      return found;
    }
    return (_ref2 = this.parent) != null ? _ref2.binding(name) : void 0;
  };

  newTypedScope = function(p, e, m) {
    var scope;
    scope = new Scope(p, e, m);
    scope.variables.length = 0;
    scope.frameSize = 0;
    return scope;
  };

  declare = function(scope, v, ty, variables, subpattern) {
    var bind, el, els, i, name, obj, objs, _i, _j, _len, _len1, _ref2, _ref3;
    if (subpattern == null) {
      subpattern = false;
    }
    if (v instanceof Value) {
      if (v.hasProperties()) {
        error(v, "cannot type properties");
      }
      v = v.base;
    }
    if (v instanceof Literal) {
      if (!ty) {
        return;
      }
      if (ty instanceof TypeArr || ty instanceof TypeObj) {
        error(v, "cannot type non-destructuring variable `" + v.value + "' with destructuring type `" + ty + "'");
      }
      name = v.value;
      if (scope.check(name)) {
        error(v, "cannot redeclare variable `" + name + "'");
      }
      bind = new Binding(ty);
      scope.add(name, bind);
      if (variables != null) {
        variables.push({
          name: name,
          type: ty,
          binding: bind
        });
      }
      if (ty instanceof StructType) {
        if (subpattern) {
          error(v, "cannot pass structs by value inside patterns");
        } else {
          putOnStack(scope, name);
        }
      }
      return;
    }
    if (v instanceof Arr) {
      els = v.objects;
      if (!(ty instanceof TypeArr)) {
        error(v, "cannot type destructuring array with non-destructuring array type `" + ty + "'");
      }
      for (i = _i = 0, _len = els.length; _i < _len; i = ++_i) {
        el = els[i];
        if (el["this"]) {
          error(v, "cannot type @-names");
        } else {
          declare(scope, el.base, ty.elements[i], variables, true);
        }
      }
      return;
    }
    if (v instanceof Obj) {
      objs = v.objects;
      if (!(ty instanceof TypeObj)) {
        error(v, "cannot type destructuring object with non-destructuring object type `" + ty + "'");
      }
      for (_j = 0, _len1 = objs.length; _j < _len1; _j++) {
        obj = objs[_j];
        if (obj instanceof Assign) {
          name = obj.variable.base;
          declare(scope, obj.value, (_ref2 = ty.names[name.value]) != null ? _ref2.type : void 0, variables, true);
        } else if (obj["this"]) {
          error(v, "cannot type @-names");
        } else {
          name = obj.base;
          declare(scope, name, (_ref3 = ty.names[name.value]) != null ? _ref3.type : void 0, variables, true);
        }
      }
      return;
    }
    return error(v, "trying to type non-typeable");
  };

  putOnStack = function(scope, name) {
    var bind;
    bind = scope.binding(name, true);
    bind.onStack = true;
    bind.spOffset = alignOffset(scope.frameSize, bind.type);
    scope.frameSize = bind.spOffset + bind.type.size;
  };

  DeclareType.prototype.declareType = function(scope, o) {
    var v, _i, _len, _ref2;
    _ref2 = this.typeables;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      v = _ref2[_i];
      declare(scope, v, this.type.lint(o.types), this.variables);
    }
    return scope;
  };

  Param.prototype.declareType = function(scope, o) {
    var _ref2;
    declare(scope, this.name, (_ref2 = this.type) != null ? _ref2.lint(o.types) : void 0, (this.variables = []));
    return scope;
  };

  Op.prototype.putOnStack = function(scope, o) {
    var inner, name;
    if (this.operator === '&' && (inner = this.first.unwrapAll()) instanceof Literal) {
      name = inner.value;
      if (scope.check(name, true)) {
        putOnStack(scope, name);
      }
    }
    return scope;
  };

  TypeAssign.prototype.collectType = function(types) {
    types[this.name] = this.type;
    return types;
  };

  alignOffset = function(offset, ty) {
    var size;
    size = ty.view.BYTES_PER_ELEMENT;
    return (((offset - 1) / size + 1) | 0) * size;
  };

  alignmentUnits = function(ty) {
    return ty.size / ty.view.BYTES_PER_ELEMENT;
  };

  TypeName.prototype.lint = function(types) {
    var linted, _ref2;
    if (this.linting) {
      error(this, "circular type synonym: " + this.name);
    }
    if (this.linted) {
      return this.linted;
    }
    this.linting = true;
    if (!(this.name in types)) {
      error(this, "cannot resolve type `" + this.name + "'");
    }
    linted = (_ref2 = types[this.name]) != null ? _ref2.lint(types) : void 0;
    delete this.linting;
    return this.linted = linted;
  };

  PointerType.prototype.size = 4;

  PointerType.prototype.view = U32;

  PointerType.prototype.baseAlignment = function() {
    var _ref2;
    return ((_ref2 = this.base) != null ? _ref2.view.BYTES_PER_ELEMENT : void 0) || 1;
  };

  PointerType.prototype.lint = function(types) {
    var base;
    if (this.linted) {
      return this;
    }
    this.linted = true;
    this.base = base = this.base.lint(types);
    if (base && !base.size) {
      error(this, "cannot take pointers of unsized type `" + base + "'");
    }
    return this;
  };

  PointerType.prototype.coerce = function(expr, ty) {
    if (!(ty instanceof PointerType && ty !== this)) {
      return expr;
    }
    if ((typeof expr.unwrapCast === "function" ? expr.unwrapCast().value : void 0) === '0') {
      return expr;
    }
    return normalizePtr(expr, ty.baseAlignment(), this.baseAlignment());
  };

  TypeArr.prototype.lint = function(types) {
    var el, i, _i, _len, _ref2;
    if (this.linted) {
      return this;
    }
    this.linted = true;
    _ref2 = this.elements;
    for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {
      el = _ref2[i];
      this.elements[i] = el.lint(types);
    }
    return this;
  };

  TypeObj.prototype.lint = function(types) {
    var field, _i, _len, _ref2;
    if (this.linted) {
      return this;
    }
    this.linted = true;
    _ref2 = this.fields;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      field = _ref2[_i];
      field.type = field.type.lint(types);
    }
    return this;
  };

  StructType.prototype.lint = function(types) {
    var align, field, field2, fields, maxView, offset, prev, s, size, ty, ty2, _i, _j, _k, _l, _len, _len1, _len2, _len3;
    if (this.linted) {
      return this;
    }
    this.linted = true;
    this.size = 1;
    fields = this.fields;
    for (_i = 0, _len = fields.length; _i < _len; _i++) {
      field = fields[_i];
      field.type = field.type.lint(types);
    }
    prev = {
      offset: 0,
      type: {
        size: 0
      }
    };
    size = 0;
    maxView = U8;
    for (_j = 0, _len1 = fields.length; _j < _len1; _j++) {
      field = fields[_j];
      ty = field.type;
      if (!ty.size) {
        error(this, "cannot store unsized type `" + ty + "' as a struct field");
      }
      if (ty.view.BYTES_PER_ELEMENT > maxView.BYTES_PER_ELEMENT) {
        maxView = ty.view;
      }
      if ((offset = field.offset) != null) {
        if (offset < 0) {
          error(this, "struct field offsets cannot be negative");
        }
        if (offset < prev.offset) {
          printWarn("offset of field `" + field.name + "' is smaller offset of previous field");
        }
        if (offset !== alignOffset(offset, ty)) {
          error(this, "manual offset [" + offset + "] cannot be aligned to `" + ty + "'");
        }
      } else if (field.usePreviousOffset) {
        if ((field.offset = alignOffset(prev.offset, ty)) !== prev.offset) {
          prev.offset = field.offset;
        }
      } else {
        field.offset = alignOffset(prev.offset + prev.type.size, ty);
      }
      if ((s = field.offset + ty.size) > size) {
        size = s;
      }
      prev = field;
    }
    for (_k = 0, _len2 = fields.length; _k < _len2; _k++) {
      field = fields[_k];
      if ((ty = field.type) instanceof PointerType) {
        for (_l = 0, _len3 = fields.length; _l < _len3; _l++) {
          field2 = fields[_l];
          if (field2.offset === field.offset && (ty2 = field2.type) instanceof PointerType) {
            unify(types, ty, ty2, true && unify(types, ty2, ty, true));
          }
        }
      }
    }
    align = maxView.BYTES_PER_ELEMENT;
    this.size = (((size - 1) / align + 1) | 0) * align;
    this.view = maxView;
    return this;
  };

  ArrowType.prototype.lint = function(types) {
    var i, params, ty, _i, _len;
    if (this.linted) {
      return this;
    }
    this.linted = true;
    ty = this.ret.lint(types);
    this.ret = ty;
    params = this.params;
    for (i = _i = 0, _len = params.length; _i < _len; i = ++_i) {
      ty = params[i];
      params[i] = ty.lint(types);
    }
    return this;
  };

  cast = function(node, ty) {
    return new Cast(node, ty, true);
  };

  unify = function(types, lty, rty, assigning) {
    var elements, ety, fields, fty, i, lfty, lpty, lptys, name, ptys, rptys, ty, _i, _j, _k, _len, _len1, _len2, _ref2, _ref3, _ref4, _ref5;
    if (lty === rty) {
      return lty;
    }
    if (!(lty && rty)) {
      return;
    }
    if (lty instanceof PointerType && rty instanceof PointerType) {
      if (assigning) {
        if (rty.base && rty.baseAlignment() < lty.baseAlignment()) {
          printWarn("incompatible pointer conversion from `" + rty + "' to `" + lty + "' may alter its value");
        }
        return lty;
      } else {
        if (lty.base === rty.base) {
          return lty;
        }
      }
    }
    if (lty instanceof ArrowType && rty instanceof ArrowType) {
      lptys = lty.params;
      rptys = rty.params;
      if (lptys.length !== rptys.length) {
        return;
      }
      ptys = [];
      for (i = _i = 0, _len = lptys.length; _i < _len; i = ++_i) {
        lpty = lptys[i];
        ptys.push(unify(types, lpty, rptys[i], assigning));
      }
      return new ArrowType(ptys, unify(types, lty.ret, rty.ret, assigning));
    }
    if (lty instanceof PointerType && __indexOf.call(integral, rty) >= 0) {
      printWarn("conversion from `" + rty + "' to pointer without cast");
      return lty;
    }
    if (__indexOf.call(integral, lty) >= 0 && rty instanceof PointerType) {
      printWarn("conversion from pointer to `" + lty + "' without cast");
      return lty;
    }
    if (lty instanceof TypeObj && rty instanceof TypeObj) {
      if (lty.fields.length !== rty.fields.length) {
        return;
      }
      fields = [];
      _ref2 = lty.fields;
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        _ref3 = _ref2[_j], name = _ref3.name, lfty = _ref3.type;
        if (!(fty = unify(types, lfty, (_ref4 = rty.names[name]) != null ? _ref4.type : void 0, assigning))) {
          return;
        }
        fields.push(new TypeObjField(name, fty));
      }
      return new TypeObj(fields);
    }
    if (lty instanceof TypeArr && rty instanceof TypeArr) {
      if (lty.elements.length !== rty.elements.length) {
        return;
      }
      elements = [];
      _ref5 = lty.elements;
      for (i = _k = 0, _len2 = _ref5.length; _k < _len2; i = ++_k) {
        ty = _ref5[i];
        if (!(ety = unify(types, ty, rty.elements[i], assigning))) {
          return;
        }
        elements.push(ety);
      }
      return new TypeArr(elements);
    }
    if (__indexOf.call(numeric, lty) >= 0 && __indexOf.call(numeric, rty) >= 0) {
      if (lty.size !== rty.size) {
        printWarn("conversion from `" + rty + "' to `" + lty + "' may alter its value");
        if (assigning) {
          return lty;
        } else if (lty.size > rty.size) {
          return lty;
        } else {
          return rty;
        }
      }
      if (lty.signed !== rty.signed) {
        printWarn("conversion from `" + rty + "' to `" + lty + "' may alter its sign");
        return lty;
      }
    }
    return null;
  };

  Base.prototype.typeTransform = function(o) {
    return this.typeTransformNode(extend({}, o));
  };

  typeTransformArray = function(o, a) {
    var el, i, _i, _len, _results;
    _results = [];
    for (i = _i = 0, _len = a.length; _i < _len; i = ++_i) {
      el = a[i];
      if (el instanceof Array && el.length) {
        _results.push(typeTransformArray(el));
      } else {
        _results.push(a[i] = el.typeTransform(o));
      }
    }
    return _results;
  };

  Base.prototype.typeTransformNode = function(o) {
    var attr, child, _i, _len, _ref2;
    _ref2 = this.children;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      attr = _ref2[_i];
      if (child = this[attr]) {
        if (child instanceof Array && child.length) {
          typeTransformArray(o, child);
        } else {
          this[attr] = child.typeTransform(o);
        }
      }
    }
    return this;
  };

  Literal.prototype.typeTransformNode = function(o) {
    var bind, i, offset, ty, val;
    if (o.isValue) {
      val = this.value;
      if (val === 'null' || (val === '0' && o.wantsToBePointer)) {
        this.value = '0';
        return cast(this, anyPtrTy);
      } else if (this.isAssignable() && (bind = o.scope.binding(val))) {
        ty = bind.type;
        if (bind.onStack) {
          offset = stackOffsetExpr(o, bind.spOffset, ty);
          if (!o.scope.check(val, true)) {
            error(this, "cannot close over non-local on-stack variable `" + name + "'");
          }
          if (ty instanceof StructType) {
            return cast(offset, ty);
          } else {
            return cast(new Value(ty.view, [new Index(offset)]), ty);
          }
        } else {
          return cast(this, ty);
        }
      } else if (this.isSimpleNumber()) {
        i = parseInt(val);
        ty = (i | 0) === i ? i32ty : (i >>> 0) === i ? u32ty : f64ty;
        return cast(this, ty);
      } else if (!isNaN(Number(val))) {
        return cast(this, f64ty);
      } else {
        return this;
      }
    } else {
      return this;
    }
  };

  Index.prototype.isConstant = function() {
    var idx;
    idx = this.index.unwrapValue();
    return idx instanceof Value && (idx.isString() || idx.isSimpleNumber());
  };

  Value.prototype.cacheTransformReference = function(ty) {
    var base, bref, casted, name;
    name = last(this.properties);
    if (this.properties.length < 2 && !this.base.isComplex()) {
      casted = cast(this, ty);
      return [casted, casted];
    }
    base = new Value(this.base, this.properties.slice(0, -1));
    if (base.isComplex()) {
      bref = new Value(new FreshLiteral('base'));
      base = new Value(new Parens(new Assign(bref, base)));
    }
    if (!name) {
      return [cast(base, ty), cast(bref, ty)];
    }
    return [cast(base.add(name), ty), cast(new Value(bref || base.base, [name]), ty)];
  };

  Value.prototype.typeTransformNode = function(o) {
    var cumulativeOffset, field, fieldName, fty, i, prop, v, vty, _i, _len, _ref2, _ref3;
    o.isValue = true;
    if (!(vty = (v = this.base.typeTransform(o)).type)) {
      return this;
    }
    cumulativeOffset = 0;
    _ref2 = this.properties;
    for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {
      prop = _ref2[i];
      if (vty instanceof PointerType) {
        vty = vty.base;
      }
      if (prop instanceof Access) {
        fieldName = prop.name.unwrapAll().value;
      } else if (prop instanceof Index && prop.isConstant()) {
        fieldName = prop.index.unwrapAll().value;
      } else {
        return this;
      }
      if (vty instanceof StructType) {
        field = vty.names[fieldName];
        if (!field) {
          error(this, "unknown struct field name `" + fieldName + "'");
        }
        if ((fty = field.type) instanceof StructType) {
          cumulativeOffset += field.offset;
        } else {
          v = makeDeref(o, v, vty, field.offset + cumulativeOffset, fty);
          vty = fty;
          cumulativeOffset = 0;
        }
      } else if (vty instanceof TypeObj) {
        if (!(vty = (_ref3 = vty.names[fieldName]) != null ? _ref3.type : void 0)) {
          return this;
        }
        v = new Value(v, [prop]);
      } else if (vty instanceof TypeArr) {
        if (!(vty = vty.elements[fieldName])) {
          return this;
        }
        v = new Value(v, [prop]);
      }
    }
    if (cumulativeOffset !== 0) {
      v = offsetExpr(v, vty, cumulativeOffset, fty);
    }
    return cast(new Value(v), vty);
  };

  Call.prototype.typeTransformNode = function(o) {
    var arg, args, aty, fty, i, paramTys, pty, types, _i, _j, _len, _len1, _ref2, _ref3, _ref4;
    fty = (this.variable = this.variable.typeTransform(o)).type;
    args = this.args;
    if (!fty) {
      for (i = _i = 0, _len = args.length; _i < _len; i = ++_i) {
        arg = args[i];
        args[i] = arg.typeTransform(o);
      }
      return this;
    }
    if (!(fty instanceof ArrowType)) {
      error(this, "calling a non-function type `" + fty + "'");
    }
    types = o.types;
    paramTys = fty.params;
    _ref2 = fty.params;
    for (i = _j = 0, _len1 = _ref2.length; _j < _len1; i = ++_j) {
      pty = _ref2[i];
      aty = (_ref3 = (args[i] = (_ref4 = args[i]) != null ? _ref4.typeTransform(o) : void 0)) != null ? _ref3.type : void 0;
      if (pty && !unify(types, pty, aty, true)) {
        error(this, "incompatible types: passing arg `" + (tystr(aty)) + "' to param `" + (tystr(pty)) + "'");
      }
    }
    return cast(this, fty.ret);
  };

  Obj.prototype.typeTransformNode = function(o) {
    var fields, i, prop, propName, propTy, propValue, propVar, props, _i, _len;
    fields = [];
    props = this.properties;
    for (i = _i = 0, _len = props.length; _i < _len; i = ++_i) {
      prop = props[i];
      if (prop.isComplex()) {
        propName = prop.variable.unwrapAll().value.toString();
        propVar = prop.variable;
        propValue = prop.value;
      } else {
        propName = prop.unwrapAll().value.toString();
        propVar = prop;
        propValue = prop;
      }
      propTy = (propValue = propValue.typeTransform(o)).type;
      if (propTy) {
        props[i] = new Assign(propVar, propValue, 'object');
        fields.push(new TypeObjField(propName, propTy));
      }
    }
    return cast(this, (fields.length ? new TypeObj(fields) : void 0));
  };

  Arr.prototype.typeTransformNode = function(o) {
    var el, els, elty, fields, i, someTyped, _i, _len;
    fields = [];
    els = this.objects;
    for (i = _i = 0, _len = els.length; _i < _len; i = ++_i) {
      el = els[i];
      elty = (el[i] = el.typeTransform(o)).type;
      fields.push(elty);
      if (elty) {
        someTyped = true;
      }
    }
    return cast(this, (someTyped ? new TypeArr(fields) : void 0));
  };

  Assign.prototype.typeTransformNode = function(o) {
    var acc, assigns, au, autoCoerce, context, fn, i, idx, isObject, left, lty, msg, obj, op, pattern, ref, right, rty, ty, val, value, variable, _i, _len, _ref2, _ref3, _ref4, _ref5, _ref6;
    lty = (variable = this.variable.typeTransform(o)).type;
    if ((fn = this.value.unwrapAll()) instanceof Code && lty instanceof ArrowType) {
      if (fn.paramTypes == null) {
        fn.paramTypes = lty.params;
      }
      if (fn.returnType == null) {
        fn.returnType = lty.ret;
      }
    }
    o.wantsToBePointer = lty instanceof PointerType && !context;
    rty = (value = this.value.typeTransform(o)).type;
    if (!lty) {
      this.variable = variable;
      this.value = value;
      return this;
    }
    autoCoerce = variable.unwrapCast().base instanceof ViewLiteral;
    if (context = this.context) {
      op = context.substr(0, context.indexOf('='));
      _ref2 = variable.expr.cacheTransformReference(variable.type), left = _ref2[0], right = _ref2[1];
      if (!(autoCoerce && left.expr === variable.expr)) {
        return (new Assign(left, new Op(op, right, value))).typeTransform(o);
      }
      rty = binopType(o, op, lty, rty);
    }
    if (!(ty = unify(o.types, lty, rty, true))) {
      msg = "incompatible types: assigning `" + (tystr(rty)) + "' to `" + lty + "'";
      if (context) {
        error(variable, msg + (" using " + context));
      } else {
        error(variable, msg);
      }
    }
    if (lty instanceof StructType) {
      return cast(inlineMemcpy(o, variable, value, lty), lty);
    } else if (lty instanceof TypeObj || lty instanceof TypeArr) {
      ref = new FreshLiteral('ref', lty);
      assigns = [new Assign(new Value(ref), value)];
      pattern = variable.expr;
      isObject = pattern.isObject();
      _ref3 = pattern.base.objects;
      for (i = _i = 0, _len = _ref3.length; _i < _len; i = ++_i) {
        obj = _ref3[i];
        idx = i;
        if (isObject) {
          if (obj instanceof Assign) {
            _ref4 = obj, (_ref5 = _ref4.variable, idx = _ref5.base), obj = _ref4.value;
          } else {
            if (obj.base instanceof Parens) {
              _ref6 = new Value(obj.unwrapAll()).cacheTransformReference(), obj = _ref6[0], idx = _ref6[1];
            } else {
              idx = obj["this"] ? obj.properties[0].name : obj;
            }
          }
        }
        if (typeof idx === 'number') {
          idx = new Literal(idx);
          acc = false;
        } else {
          acc = isObject && idx.isAssignable() || false;
        }
        val = new Value(ref, [new (acc ? Access : Index)(idx)]);
        assigns.push((new Assign(obj, val, null, {
          param: this.param
        })).typeTransform(o));
      }
      assigns.push(new Value(ref));
      return cast(new Value(new Parens(new Block(assigns))), lty);
    } else {
      this.variable = variable;
      if (autoCoerce) {
        if (context && lty instanceof PointerType && (au = alignmentUnits(lty.base)) !== 1) {
          this.value = cast(multExpr(value, au), lty);
        } else {
          this.value = value;
        }
      } else {
        this.value = cast(value, lty);
      }
      return cast(this, lty);
    }
  };

  Code.prototype.typeTransformNode = function(o) {
    var arg, b, body, expr, exprs, frameSize, hasExpr, i, implicitReturn, param, plh, prh, ptys, restoreStack, ret, rets, rexpr, rty, scope, tmp, types, unsafeSpRestore, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
    if (rty = this.returnType instanceof ArrowType) {
      _ref2 = returnExpressions(this.body);
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        rexpr = _ref2[_i];
        if (!(rexpr instanceof Code)) {
          continue;
        }
        if (rexpr.paramTypes == null) {
          rexpr.paramTypes = rty.params;
        }
        if (rexpr.returnType == null) {
          rexpr.returnType = rty.ret;
        }
      }
    }
    scope = newTypedScope(o.scope, this.body, this);
    ptys = this.paramTypes;
    if (ptys) {
      if (ptys.length !== this.params.length) {
        error(this, "arrow type has different number of parameters than function");
      }
      types = o.types;
      _ref3 = this.params;
      for (i = _j = 0, _len1 = _ref3.length; _j < _len1; i = ++_j) {
        param = _ref3[i];
        param.type = ptys[i];
        scope = param.declareType(scope, o);
      }
    }
    o.scope = this.body.foldChildren(this.body.foldChildren(scope, 'declareType', o), 'putOnStack', o);
    exprs = this.body.expressions;
    _ref4 = lastNonCommentOrDecl(exprs), implicitReturn = _ref4[0], i = _ref4[1];
    if (!implicitReturn.jumps()) {
      exprs[i] = new Return(implicitReturn);
    }
    if (frameSize = o.scope.frameSize) {
      _ref5 = this.params;
      for (_k = 0, _len2 = _ref5.length; _k < _len2; _k++) {
        param = _ref5[_k];
        _ref6 = param.variables;
        for (_l = 0, _len3 = _ref6.length; _l < _len3; _l++) {
          arg = _ref6[_l];
          if (!arg.binding.onStack) {
            continue;
          }
          plh = new Value(new Literal(arg.name));
          prh = cast(new Value(new Literal(arg.name)), arg.binding.type);
          exprs.unshift(new Assign(plh, prh));
        }
      }
      if (frameSize) {
        stackFence(o, exprs, frameSize);
      }
    }
    body = this.body.typeTransform(o);
    if (body instanceof Cast) {
      body = body.expr;
    }
    types = o.types;
    _ref7 = rets = collectReturns(body);
    for (i = _m = 0, _len4 = _ref7.length; _m < _len4; i = ++_m) {
      ret = _ref7[i];
      rexpr = ret.expression;
      if (i === 0) {
        rty = rexpr != null ? rexpr.type : void 0;
      } else {
        rty = unify(types, rexpr != null ? rexpr.type : void 0, rty);
      }
    }
    unsafeSpRestore = frameSize && opts.unsafe;
    if (unsafeSpRestore || rty) {
      if (unsafeSpRestore) {
        restoreStack = new Assign(SPREAL, new Value(new Literal(frameSize)), '+=');
      }
      for (_n = 0, _len5 = rets.length; _n < _len5; _n++) {
        ret = rets[_n];
        hasExpr = ret.expression != null;
        if (rty && hasExpr) {
          ret.expression = cast(ret.expression, rty);
        }
        if (unsafeSpRestore) {
          if (hasExpr) {
            expr = ret.expression;
            tmp = new Value(new FreshLiteral('t', expr.type));
            b = [new Assign(tmp, expr), restoreStack, tmp];
          } else {
            b = [restoreStack, undefExpr];
          }
          ret.expression = new Value(new Parens(new Block(b)));
        }
      }
    }
    this.body = body;
    return cast(this, new ArrowType(ptys, rty));
  };

  ARITH = ['+', '-', '*', '/'];

  BITWISE = ['<<', '>>', '>>>', '~', '&', '|'];

  COMPARE = ['===', '!==', '<', '>', '<=', '>='];

  binopType = function(o, op, ty1, ty2, node) {
    if ((op === '+' || op === '-') && ty1 instanceof PointerType) {
      if (__indexOf.call(integral, ty2) >= 0) {
        return ty1;
      } else if (op === '-' && ty2 instanceof PointerType) {
        if (!unify(o.types, ty1.base, ty2.base)) {
          printWarn("pointer subtraction on incompatible pointer types `" + (tystr(ty1)) + "' and `" + ty2 + "'");
        }
        return i32ty;
      } else {
        return error(node, "invalid operand type `" + (tystr(ty2)) + "' for pointer arithmetic");
      }
    } else if (op === '%') {
      return i32ty;
    } else if (__indexOf.call(COMPARE, op) >= 0) {
      if (ty1 instanceof PointerType && ty2 instanceof PointerType && !unify(o.types, ty1, ty2)) {
        printWarn("comparison between incompatible pointer types `" + (tystr(ty1)) + "' and `" + (tystr(ty2)) + "'");
      }
      return i32ty;
    } else if (__indexOf.call(BITWISE, op) >= 0) {
      return i32ty;
    } else if (__indexOf.call(ARITH, op) >= 0 && __indexOf.call(numeric, ty1) >= 0 && __indexOf.call(numeric, ty2) >= 0) {
      return f64ty;
    }
  };

  Op.prototype.typeTransformNode = function(o) {
    var addr, asn, assigns, au, first, left, op, pointerSecond, right, tmp, ty, ty1, ty2, _ref2, _ref3;
    op = this.operator;
    if (this.isUnary()) {
      if (op === 'new' && this.first.unwrapAll().value in o.types) {
        ty1 = o.types[this.first.unwrapAll().value];
        if (!(ty1 != null ? ty1.size : void 0)) {
          error(this, "cannot allocate unsized type `" + ty1 + "'");
        }
        Scope.root.needsMalloc = true;
        return cast(new Call(MALLOC, [new Value(new Literal(ty1.size))]), new PointerType(ty1));
      } else if (op === 'delete' && (_ref2 = this.first.typeTransform(o && ty1), first = _ref2[0], ty1 = _ref2[1], _ref2)) {
        if (!(ty1 instanceof PointerType)) {
          error(this, 'cannot free non-pointer type');
        }
        Scope.root.needsMalloc = true;
        return cast(new Call(FREE, [first]), unit);
      } else if (op === 'sizeof') {
        ty1 = this.first = this.first.lint(o.types);
        if (!ty1.size) {
          error(this, "cannot determine size of type `" + ty1 + "'");
        }
        return cast(new Literal(ty1.size), i32ty);
      } else if (op === '&') {
        ty1 = (first = this.first.typeTransform(o)).type;
        if (!ty1) {
          error(this, "taking reference of an untyped expression `" + (this.first.compile(o)) + "'");
        }
        if (ty1 instanceof ArrowType) {
          error(this, "taking reference of a function type");
        }
        if (!this.first.isAssignable()) {
          error(this, "taking reference of non-assignable");
        }
        ty = new PointerType(ty1);
        addr = ty1 instanceof StructType ? first : first.expr.properties[0].index;
        return cast(addr, ty);
      } else if (op === '*') {
        ty1 = (first = this.first.typeTransform(o)).type;
        if (!ty1) {
          error(this, "dereferencing untyped expression");
        }
        if (!(ty1 instanceof PointerType)) {
          error(this, "dereferencing a non-pointer type");
        }
        if ((ty1 = ty1.base) instanceof StructType) {
          return cast(first, ty1);
        } else {
          return cast(makeDeref(o, first, ty1, 0, ty1), ty1);
        }
      } else if ((op === '++' || op === '--') && (ty1 = (first = this.first.typeTransform(o)).type) && (ty1 instanceof PointerType || __indexOf.call(numeric, ty1) >= 0)) {
        _ref3 = first.expr.cacheTransformReference(ty1), left = _ref3[0], right = _ref3[1];
        tmp = new Value(new FreshLiteral('t', ty1));
        asn = new Assign(right, new Value(new Literal('1')), op === '++' ? '+=' : '-=');
        assigns = [new Assign(tmp, left), asn.typeTransform(o), tmp];
        return cast(new Value(new Parens(new Block(assigns))), ty1);
      } else {
        this.first = this.first.typeTransform(o);
        return this;
      }
    } else {
      ty1 = (this.first = this.first.typeTransform(o)).type;
      ty2 = (this.second = this.second.typeTransform(o)).type;
      pointerSecond = ty2 instanceof PointerType;
      ty = binopType(o, op, (pointerSecond ? ty2 : ty1), (pointerSecond ? ty1 : ty2), this);
      if ((op === '+' || op === '-') && ((ty1 instanceof PointerType && __indexOf.call(integral, ty2) >= 0 && (au = alignmentUnits(ty1.base)) !== 1) || (ty2 instanceof PointerType && __indexOf.call(integral, ty1) >= 0 && (au = alignmentUnits(ty2.base)) !== 1))) {
        if (ty1 instanceof PointerType) {
          this.second = multExpr(this.second, au);
        } else {
          this.first = multExpr(this.first, au);
        }
      } else if (__indexOf.call(COMPARE, op) >= 0 && ty1 instanceof PointerType && ty2 instanceof PointerType) {
        this.second = cast(this.second, ty1);
      }
      return cast(this, ty);
    }
  };

  Parens.prototype.typeTransformNode = function(o) {
    this.body = this.body.typeTransformNode(o);
    return cast(this, this.body.type);
  };

  Block.prototype.typeTransformNode = function(o) {
    var expr, exprs, i, ty, _i, _len, _ref2;
    if (!o.isValue) {
      return Block.__super__.typeTransformNode.call(this, o);
    }
    _ref2 = exprs = this.expressions;
    for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {
      expr = _ref2[i];
      exprs[i] = expr.typeTransform(o);
      if (i === exprs.length - 1) {
        if (!expr.jumps()) {
          ty = exprs[i].type;
          return cast(this, ty);
        }
        return this;
      }
    }
  };

  Switch.prototype.computeNodeType = function(o) {
    var block, c, caseTys, cty, i, otherwiseTy, someCaseJumps, someCaseTyped, ty, types, _i, _len, _ref2;
    if (!o.isValue) {
      return Switch.__super__.computeNodeType.call(this, o);
    }
    this.subject = this.subject.typeTransform(o);
    types = o.types;
    caseTys = [];
    someCaseJumps = false;
    someCaseTyped = false;
    _ref2 = this.cases;
    for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {
      c = _ref2[i];
      block = c.block;
      if (block.jumps()) {
        ty = null;
        someCaseJumps = true;
      } else {
        ty = (c.block = block.typeTransform(o)).type;
      }
      caseTys.push(ty);
      if (ty) {
        someCaseTyped = true;
      }
      if (i === 0) {
        cty = ty;
      } else {
        cty = unify(types, ty, cty);
      }
    }
    if (this.otherwise) {
      otherwiseTy = (this.otherwise = this.otherwise.typeTransform(o)).type;
      cty = unify(types, otherwiseTy, cty);
    }
    if (someCaseTyped && !cty) {
      if (someCaseJumps) {
        printWarn("cannot type switch with jumps");
      } else {
        printWarn("branches of switch have different types: `" + (((function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = caseTys.length; _j < _len1; _j++) {
            ty = caseTys[_j];
            _results.push(tystr(ty));
          }
          return _results;
        })()).join('\', `')) + "'");
      }
    }
    return cast(this, cty);
  };

  If.prototype.typeTransformNode = function(o) {
    var elseTy, thenTy, ty, _ref2, _ref3, _ref4, _ref5;
    if (!o.isValue) {
      return If.__super__.typeTransformNode.call(this, o);
    }
    this.condition = this.condition.typeTransform(o);
    thenTy = (_ref2 = (this.body = (_ref3 = this.body) != null ? _ref3.typeTransform(o) : void 0)) != null ? _ref2.type : void 0;
    elseTy = (_ref4 = (this.elseBody = (_ref5 = this.elseBody) != null ? _ref5.typeTransform(o) : void 0)) != null ? _ref4.type : void 0;
    ty = unify(o.types, thenTy, elseTy);
    if ((thenTy || elseTy) && !ty) {
      printWarn("branches of if have different types: `" + (tystr(thenTy)) + "' and `" + (tystr(elseTy)) + "'");
    }
    return cast(this, ty);
  };

  Cast.prototype.typeTransformNode = function(o) {
    if (!this.generated) {
      this.type = this.type.lint(o.types);
      this.expr = this.expr.typeTransform(o);
    }
    return this;
  };

  PrimitiveType = (function() {

    function PrimitiveType(size, debugName, view, signed, coerce) {
      this.size = size;
      this.debugName = debugName;
      this.view = view;
      this.signed = signed;
      this.coerce = coerce;
    }

    PrimitiveType.prototype.lint = function(types) {
      return this;
    };

    PrimitiveType.prototype.toString = function() {
      return this.debugName;
    };

    return PrimitiveType;

  })();

  anyPtrTy = new PointerType(null);

  unit = new PrimitiveType(0, 'unit');

  i8ty = new PrimitiveType(1, 'i8', I8, true, coerceIntegral(8, true));

  u8ty = new PrimitiveType(1, 'u8', U8, false, coerceIntegral(8, false));

  i16ty = new PrimitiveType(2, 'i16', I16, true, coerceIntegral(16, true));

  u16ty = new PrimitiveType(2, 'u16', U16, false, coerceIntegral(16, false));

  i32ty = new PrimitiveType(4, 'i32', I32, true, coerceIntegral(32, true));

  u32ty = new PrimitiveType(4, 'u32', U32, false, coerceIntegral(32, false));

  f64ty = new PrimitiveType(8, 'double', F64, true);

  integral = [i8ty, u8ty, i16ty, u16ty, i32ty, u32ty];

  numeric = integral.concat([f64ty]);

  requireExpr = function(name) {
    return new Call(new Value(new Literal('require')), [new Value(new Literal("'" + name + "'"))]);
  };

  exports.analyzeTypes = function(root, o) {
    var exprs, frameSize, initialTypes, name, obj, scope, ty, types, usesTypes;
    if (o == null) {
      o = {};
    }
    usesTypes = false;
    root.traverseChildren(true, function(node) {
      if ((node instanceof DeclareType) || (node instanceof TypeAssign) || (node instanceof Op && node.isUnary() && (node.operator === '&' || node.operator === '*')) || (node instanceof Code && node.paramTypes)) {
        usesTypes = true;
        return false;
      }
    });
    if (!usesTypes) {
      return root;
    }
    opts.warn = o.warn;
    opts.unsafe = o.unsafe;
    initialTypes = {
      any: null,
      i8: i8ty,
      u8: u8ty,
      i16: i16ty,
      u16: u16ty,
      i32: i32ty,
      u32: u32ty,
      byte: u8ty,
      short: i16ty,
      int: i32ty,
      uint: u32ty,
      double: f64ty,
      num: f64ty
    };
    types = root.foldChildren(initialTypes, 'collectType', {
      immediate: true
    });
    for (name in types) {
      ty = types[name];
      if (ty) {
        types[name] = ty.lint(types);
      }
    }
    o = {
      types: types
    };
    scope = newTypedScope(null, root, null);
    o.scope = root.foldChildren(root.foldChildren(scope, 'declareType', o), 'putOnStack', o);
    exprs = root.expressions;
    if (frameSize = o.scope.frameSize) {
      o.frameSize = frameSize;
      stackFence(o, exprs, frameSize, true);
    }
    root.typeTransform(o);
    if (Scope.root.needsMalloc) {
      obj = new Value(new Obj([MALLOC, FREE]));
      exprs.unshift(new Assign(obj, requireExpr('heap/malloc')));
    }
    root.transformRoot = function(o) {
      return o.scope.assign(HEAP.base.value, "require('heap/heap')");
    };
    return root;
  };

}).call(this);
