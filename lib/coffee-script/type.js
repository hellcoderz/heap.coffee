// Generated by CoffeeScript 1.3.1
(function() {
  var ArrowType, Assign, Base, Block, Call, Code, DeclareType, Deref, FREE, HEAP, HEAPV, Index, Literal, MALLOC, Op, PointerType, PrimitiveType, Ref, STACK, STACKV, Scope, StructType, TypeAssign, TypeName, Value, anyPtrTy, byteTy, extend, flatten, intTy, newTypedScope, primitiveTypes, shortTy, uintTy, unify, unitTy, _ref, _ref1,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Scope = require('./scope').Scope;

  _ref = require('./nodes'), Base = _ref.Base, Block = _ref.Block, Value = _ref.Value, Literal = _ref.Literal, Op = _ref.Op, Assign = _ref.Assign, Code = _ref.Code, Index = _ref.Index, Call = _ref.Call, TypeAssign = _ref.TypeAssign, DeclareType = _ref.DeclareType, Ref = _ref.Ref, Deref = _ref.Deref, TypeName = _ref.TypeName, PointerType = _ref.PointerType, ArrowType = _ref.ArrowType, StructType = _ref.StructType;

  _ref1 = require('./helpers'), flatten = _ref1.flatten, extend = _ref1.extend;

  HEAP = new Literal('_H');

  HEAPV = new Value(HEAP);

  STACK = new Literal('_S');

  STACKV = new Value(STACK);

  MALLOC = new Literal('_malloc');

  FREE = new Literal('_free');

  Scope.prototype.typeOf = function(name, immediate) {
    var found, _ref2;
    found = this.type(name);
    if (found || immediate) {
      return found;
    }
    return (_ref2 = this.parent) != null ? _ref2.typeOf(name) : void 0;
  };

  Base.prototype.foldChildren = function(r, m, o) {
    var attr, child, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref2, _ref3, _ref4, _ref5;
    r = typeof this[m] === 'function' ? this[m](r, o) : r;
    if (!this.children) {
      return r;
    }
    if (o.immediate) {
      _ref2 = this.children;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        attr = _ref2[_i];
        if (this[attr]) {
          _ref3 = flatten([this[attr]]);
          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
            child = _ref3[_j];
            r = typeof child[m] === 'function' ? child[m](r, o) : r;
          }
        }
      }
    } else {
      _ref4 = this.children;
      for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
        attr = _ref4[_k];
        if (this[attr]) {
          _ref5 = flatten([this[attr]]);
          for (_l = 0, _len3 = _ref5.length; _l < _len3; _l++) {
            child = _ref5[_l];
            r = child.foldChildren(r, m, o);
          }
        }
      }
    }
    return r;
  };

  Block.prototype.foldChildren = function(r, m, o) {
    return Block.__super__.foldChildren.call(this, r, m, extend({}, o));
  };

  Code.prototype.foldChildren = function(r, m, o) {
    if (!o.crossScope) {
      return r;
    }
    return Code.__super__.foldChildren.call(this, r, m, extend({}, o));
  };

  TypeAssign.prototype.collectType = function(types) {
    var _base;
    types[this.name] = this.type;
    if ((_base = this.type).debugName == null) {
      _base.debugName = this.name;
    }
    return types;
  };

  TypeName.prototype.lint = function(types) {
    var linted, ty;
    if (this.linting) {
      throw TypeError("circular type synonym: " + this.name);
    }
    if (this.linted) {
      return this.linted;
    }
    this.linting = true;
    if (!(ty = types[this.name])) {
      throw TypeError("cannot resolve type `" + this.name + "'");
    }
    linted = ty.lint(types);
    delete this.linting;
    return this.linted = linted;
  };

  PointerType.prototype.size = 4;

  PointerType.prototype.lint = function(types) {
    if (this.linted) {
      return this;
    }
    this.linted = true;
    this.base = this.base.lint(types);
    if (this.base instanceof ArrowType) {
      throw TypeError("cannot take pointers of function types");
    }
    return this;
  };

  StructType.prototype.lint = function(types) {
    var field, size, _i, _j, _len, _len1, _ref2, _ref3;
    if (this.linted) {
      return this;
    }
    this.linted = true;
    _ref2 = this.fields;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      field = _ref2[_i];
      field.type = field.type.lint(types);
    }
    size = 0;
    _ref3 = this.fields;
    for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
      field = _ref3[_j];
      field.offset = size;
      size += field.type.size;
    }
    this.size = size;
    return this;
  };

  ArrowType.prototype.lint = function(types) {
    var i, ty, _i, _len, _ref2;
    if (this.linted) {
      return this;
    }
    this.linted = true;
    ty = this.ret.lint(types);
    if (ty instanceof ArrowType) {
      throw TypeError("cannot type higher-order functions");
    }
    this.ret = ty;
    _ref2 = this.params;
    for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {
      ty = _ref2[i];
      ty = ty.lint(types);
      if (ty instanceof ArrowType) {
        throw TypeError("cannot type higher-order functions");
      }
      params[i] = ty;
    }
    return this;
  };

  unify = function(types, ty1, ty2) {
    var base;
    if (ty1 === ty2) {
      return ty1;
    }
    if (ty1 instanceof PointerType && ty2 === anyPtrTy) {
      return ty1;
    }
    if (ty2 instanceof PointerType && ty1 === anyPtrTy) {
      return ty2;
    }
    if (ty1 instanceof PointerType && ty2 instanceof PointerType) {
      base = unify(types, ty1.base, ty2.base);
      if (base) {
        return new PointerType(base);
      }
    }
    return null;
  };

  Base.prototype.isTyped = function(o) {
    var scope, types;
    types = o.types;
    scope = o.typedScope;
    if (!(types && scope)) {
      return false;
    }
    return !!(this.computeType(types, scope));
  };

  Base.prototype.computeType = function(types, scope) {};

  Literal.prototype.computeType = function(types, scope) {
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    return this.computedType = this.value === 'null' ? anyPtrTy : this.isAssignable() ? scope.typeOf(this.value) : this.isSimpleNumber() ? intTy : void 0;
  };

  Assign.prototype.computeType = function(types, scope) {
    var lhTy, rhTy;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    if (!(lhTy = this.variable.unwrapAll().computeType(types, scope))) {
      return;
    }
    rhTy = this.value.unwrapAll().computeType(types, scope);
    if (!rhTy) {
      throw TypeError('cannot assign untyped to typed');
    }
    if (!(this.computedType = unify(types, lhTy, rhTy))) {
      throw TypeError("incompatible types in assignment: `" + lhTy + "' and `" + rhTy + "'");
    }
  };

  Value.prototype.computeType = function(types, scope) {
    var baseTy, field, fieldName, prop, _i, _len, _ref2;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    if (baseTy = this.base.unwrapAll().computeType(types, scope)) {
      _ref2 = this.properties;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        prop = _ref2[_i];
        if (baseTy instanceof PointerType) {
          baseTy = baseTy.base;
        }
        if (!(baseTy instanceof StructType)) {
          return;
        }
        if (prop.soak) {
          throw TypeError("cannot soak field names");
        }
        fieldName = prop.name.unwrapAll().value;
        field = baseTy.names[fieldName];
        if (!field) {
          throw TypeError("unknown struct field name `" + fieldName + "'");
        }
        prop.computedOffset = field.offset;
        baseTy = field.type;
      }
      return this.computedType = baseTy;
    }
  };

  Op.prototype.computeType = function(types, scope) {
    var ARITH_OPS, first, op, primTys, tmp, ty1, ty2;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    op = this.operator;
    if (this.isUnary()) {
      first = this.first.unwrapAll();
      return this.computedType = (function() {
        if (op === 'new' && (ty1 = types[first.value])) {
          if (!ty1.size) {
            throw TypeError('cannot allocate type with size 0');
          }
          return new PointerType(ty1);
        } else if (op === 'delete' && (ty1 = first.computeType(types, scope))) {
          if (!(ty1 instanceof PointerType)) {
            throw TypeError('cannot free non-pointer type');
          }
          if (ty1.onStack) {
            throw TypeError('cannot free on-stack variables');
          }
          return unitTy;
        }
      })();
    }
    ty1 = this.first.unwrapAll().computeType(types, scope);
    ty2 = this.second.unwrapAll().computeType(types, scope);
    if (ty2 instanceof PointerType) {
      tmp = ty1;
      ty1 = ty2;
      ty2 = tmp;
    }
    ARITH_OPS = ['+', '-', '*', '/', '<<', '>>', '>>>', '~', '&', '|'];
    primTys = [byteTy, shortTy, intTy, uintTy];
    return this.computedType = op === '+' && ty1 instanceof PointerType && __indexOf.call(primTys, ty2) >= 0 ? ty1 : op === '-' && ty1 instanceof PointerType && ty2 instanceof PointerType ? unify(types, ty1.base, ty2.base) ? intTy : void 0 : __indexOf.call(ARITH_OPS, op) >= 0 && __indexOf.call(primTys, ty1) >= 0 && __indexOf.call(primTys, ty2) >= 0 ? intTy : void 0;
  };

  Ref.prototype.computeType = function(types, scope) {
    var ty;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    ty = this.expr.unwrapAll().computeType(types, scope);
    if (!ty) {
      throw TypeError("taking reference of an untyped expression:\n" + this.expr);
    }
    if (ty instanceof ArrowType) {
      throw TypeError("taking reference of a function type");
    }
    return this.computedType = new PointerType(ty);
  };

  Deref.prototype.computeType = function(types, scope) {
    var ty;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    ty = this.expr.unwrapAll().computeType(types, scope);
    if (!ty) {
      throw TypeError("dereferencing an untyped expression:\n" + this.expr);
    }
    if (!(ty instanceof PointerType && !ty.onStack)) {
      throw TypeError("dereferencing a non-pointer type");
    }
    return this.computedType = ty.base;
  };

  newTypedScope = newTypedScope = function(p, e, m) {
    var scope;
    scope = new Scope(p, e, m);
    scope.variables.length = 0;
    return scope;
  };

  Block.prototype.inferType = function(r, o) {
    o.scope = newTypedScope(o.scope, this.body, this);
  };

  DeclareType.prototype.inferType = function(r, o) {
    var types;
    types = o.types;
    this.type = this.type.lint(types);
    if (this.type instanceof StructType) {
      this.type = new PointerType(this.type, true);
    }
    o.scope.add(this.variable.unwrapAll().value, this.type);
  };

  Literal.prototype.inferType = function(r, o) {
    this.computeType(o.types, o.scope);
  };

  Assign.prototype.inferType = function(r, o) {
    var exprs, fn, i, name, p, paramTys, ty, _i, _len, _ref2;
    if ((fn = this.value.unwrapAll()) instanceof Code && (name = this.variable.unwrapAll()) instanceof Literal && name.isAssignable()) {
      if ((ty = o.scope.typeOf(name.value)) instanceof ArrowType) {
        exprs = fn.body.expressions;
        paramTys = ty.params;
        _ref2 = fn.params;
        for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {
          p = _ref2[i].name;
          if (paramTys[i] && p instanceof Literal) {
            exprs.unshift(new DeclareType(p, paramTys[i]));
          }
        }
      }
    }
    this.computeType(o.types, o.scope);
  };

  Value.prototype.inferType = function(r, o) {
    this.computeType(o.types, o.scope);
  };

  Op.prototype.inferType = function(r, o) {
    this.computeType(o.types, o.scope);
  };

  Ref.prototype.inferType = function(r, o) {
    this.computeType(o.types, o.scope);
  };

  Deref.prototype.inferType = function(r, o) {
    this.computeType(o.types, o.scope);
  };

  Value.prototype.transform = function() {
    var getExpr, heapOffset, inner, props;
    props = this.properties;
    if (!(this.computedType && props.length)) {
      return;
    }
    heapOffset = function(idx, prop) {
      return new Value(HEAP, [new Index(new Op('+', idx, new Value(new Literal(prop.computedOffset))))]);
    };
    getExpr = function() {
      return this.expr;
    };
    inner = this.base.unwrapAll();
    if (inner instanceof Deref) {
      inner.transform = getExpr;
    }
    return props.reduce(heapOffset, this.base);
  };

  Op.prototype.transform = function() {
    var m, op, ty;
    op = this.operator;
    if (op === 'new' && (ty = this.computedType)) {
      m = ty.onStack ? STACKV : HEAPV;
      return new Call(new Value(MALLOC), [m, new Value(new Literal(ty.base.size))]);
    } else if (op === 'delete' && this.first.computedType) {
      return new Call(new Value(FREE), [HEAPV, this.first]);
    } else if (this.computedType && !this.isUnary()) {
      if (op === '+' && (ty = this.first.computedType) instanceof PointerType) {
        return new Op('+', this.first, new Op('*', this.second, new Literal(ty.base.size)));
      } else if (op === '+' && (ty = this.second.computedType) instanceof PointerType) {
        return new Op('+', new Op('*', this.first, new Literal(ty.base.size)), this.second);
      } else if (op === '-' && (ty = this.first.computedType) instanceof PointerType) {
        this.transform = null;
        return new Op('>>', this, new Literal(Math.log(ty.base.size) / Math.log(2)));
      }
    }
  };

  Ref.prototype.transform = function() {
    return this.expr;
  };

  Deref.prototype.transform = function() {
    return new Value(HEAP, [new Index(this.expr)]);
  };

  PrimitiveType = (function() {

    function PrimitiveType(size, debugName) {
      this.size = size;
      this.debugName = debugName;
    }

    PrimitiveType.prototype.lint = function(types) {
      return this;
    };

    PrimitiveType.prototype.toString = function() {
      return this.debugName;
    };

    return PrimitiveType;

  })();

  anyPtrTy = new PrimitiveType(0, '*');

  unitTy = new PrimitiveType(0, '()');

  byteTy = new PrimitiveType(1, 'byte');

  shortTy = new PrimitiveType(2, 'short');

  intTy = new PrimitiveType(4, 'int');

  uintTy = new PrimitiveType(4, 'uint');

  primitiveTypes = {
    byte: byteTy,
    short: shortTy,
    int: intTy,
    uint: uintTy
  };

  exports.analyzeTypes = function(root) {
    var name, o, scope, ty, types;
    if (!root.containsType(DeclareType)) {
      return;
    }
    types = root.foldChildren(primitiveTypes, 'collectType', {
      immediate: true
    });
    for (name in types) {
      ty = types[name];
      types[name] = ty.lint(types);
    }
    scope = newTypedScope(null, root, null);
    o = {
      types: types,
      scope: scope,
      crossScope: true
    };
    root.foldChildren(null, 'inferType', o);
    return types;
  };

}).call(this);
