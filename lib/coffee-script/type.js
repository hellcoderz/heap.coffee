// Generated by CoffeeScript 1.3.1
(function() {
  var Access, ArrowType, Assign, Base, Block, Call, Code, DeclareType, Deref, FREE, HEAP, HEAPV, I16H, I32H, Index, Literal, MALLOC, MEMCPY, Obj, Op, Parens, PointerType, PrimitiveType, Ref, Return, STACK, STACKV, Scope, StructType, TypeAssign, TypeName, U16H, U32H, Value, While, anyPtrTy, byteTy, extend, flatten, inlineMemcpy, intTy, makeDeref, newTypedScope, primitiveTypes, returnExpressions, shiftBy, shortTy, structLiteral, uintTy, unify, unitTy, _ref, _ref1,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Scope = require('./scope').Scope;

  _ref = require('./nodes'), Base = _ref.Base, Parens = _ref.Parens, Block = _ref.Block, Value = _ref.Value, Literal = _ref.Literal, Op = _ref.Op, Assign = _ref.Assign, Code = _ref.Code, Index = _ref.Index, Access = _ref.Access, Call = _ref.Call, Return = _ref.Return, Obj = _ref.Obj, While = _ref.While, TypeAssign = _ref.TypeAssign, DeclareType = _ref.DeclareType, Ref = _ref.Ref, Deref = _ref.Deref, TypeName = _ref.TypeName, PointerType = _ref.PointerType, ArrowType = _ref.ArrowType, StructType = _ref.StructType;

  _ref1 = require('./helpers'), flatten = _ref1.flatten, extend = _ref1.extend;

  HEAP = new Literal('H');

  HEAPV = new Value(HEAP);

  STACK = new Literal('S');

  STACKV = new Value(STACK);

  I16H = new Literal('I16H');

  U16H = new Literal('U16H');

  I32H = new Literal('I32H');

  U32H = new Literal('U32H');

  MALLOC = new Value(new Literal('malloc'));

  FREE = new Value(new Literal('free'));

  MEMCPY = new Value(new Literal('memcpy'));

  shiftBy = function(size) {
    return Math.log(size) / Math.log(2);
  };

  Scope.prototype.typeOf = function(name, immediate) {
    var found, _ref2;
    found = this.type(name);
    if (found || immediate) {
      return found;
    }
    return (_ref2 = this.parent) != null ? _ref2.typeOf(name) : void 0;
  };

  Base.prototype.foldChildren = function(r, pre, post, o) {
    var attr, child, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref2, _ref3, _ref4, _ref5;
    r = typeof this[pre] === 'function' ? this[pre](r, o) : r;
    if (!this.children) {
      return r;
    }
    if (o.immediate) {
      _ref2 = this.children;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        attr = _ref2[_i];
        if (this[attr]) {
          _ref3 = flatten([this[attr]]);
          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
            child = _ref3[_j];
            r = typeof child[pre] === 'function' ? child[pre](r, o) : r;
            r = post && typeof child[post] === 'function' ? child[post](r, o) : r;
          }
        }
      }
    } else {
      _ref4 = this.children;
      for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
        attr = _ref4[_k];
        if (this[attr]) {
          _ref5 = flatten([this[attr]]);
          for (_l = 0, _len3 = _ref5.length; _l < _len3; _l++) {
            child = _ref5[_l];
            r = child.foldChildren(r, pre, post, o);
          }
        }
      }
    }
    if (post && typeof this[post] === 'function') {
      return this[post](r, o);
    } else {
      return r;
    }
  };

  Block.prototype.foldChildren = function(r, pre, post, o) {
    return Block.__super__.foldChildren.call(this, r, pre, post, extend({}, o));
  };

  Code.prototype.foldChildren = function(r, pre, post, o) {
    if (!o.crossScope) {
      return r;
    }
    return Code.__super__.foldChildren.call(this, r, pre, post, o);
  };

  TypeAssign.prototype.collectType = function(types) {
    var _base;
    types[this.name] = this.type;
    if ((_base = this.type).debugName == null) {
      _base.debugName = this.name;
    }
    return types;
  };

  TypeName.prototype.lint = function(types) {
    var linted, ty;
    if (this.linting) {
      throw TypeError("circular type synonym: " + this.name);
    }
    if (this.linted) {
      return this.linted;
    }
    this.linting = true;
    if (!(ty = types[this.name])) {
      throw TypeError("cannot resolve type `" + this.name + "'");
    }
    linted = ty.lint(types);
    delete this.linting;
    return this.linted = linted;
  };

  PointerType.prototype.size = 4;

  PointerType.prototype.lint = function(types) {
    if (this.linted) {
      return this;
    }
    this.linted = true;
    this.base = this.base.lint(types);
    if (this.base instanceof ArrowType) {
      throw TypeError("cannot take pointers of function types");
    }
    return this;
  };

  StructType.prototype.lint = function(types) {
    var field, size, _i, _j, _len, _len1, _ref2, _ref3;
    if (this.linted) {
      return this;
    }
    this.linted = true;
    _ref2 = this.fields;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      field = _ref2[_i];
      field.type = field.type.lint(types);
    }
    size = 0;
    _ref3 = this.fields;
    for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
      field = _ref3[_j];
      field.offset = size;
      size += field.type.size;
    }
    this.size = size;
    return this;
  };

  ArrowType.prototype.lint = function(types) {
    var i, params, ty, _i, _len;
    if (this.linted) {
      return this;
    }
    this.linted = true;
    ty = this.ret.lint(types);
    this.ret = ty;
    params = this.params;
    for (i = _i = 0, _len = params.length; _i < _len; i = ++_i) {
      ty = params[i];
      params[i] = ty.lint(types);
    }
    return this;
  };

  unify = function(types, ty1, ty2) {
    var base, i, pty, pty1, ptys, ptys1, ptys2, rty, _i, _len;
    if (ty1 === ty2) {
      return ty1;
    }
    if (!ty2) {
      return ty1;
    }
    if (!ty1) {
      return ty2;
    }
    if (ty1 instanceof PointerType && ty2 === anyPtrTy) {
      return ty1;
    }
    if (ty2 instanceof PointerType && ty1 === anyPtrTy) {
      return ty2;
    }
    if (ty1 instanceof PointerType && ty2 instanceof PointerType) {
      base = unify(types, ty1.base, ty2.base);
      if (base) {
        return new PointerType(base);
      }
    }
    if (ty1 instanceof ArrowType && ty2 instanceof ArrowType) {
      ptys1 = ty1.params;
      ptys2 = ty2.params;
      if (ptys1.length !== ptys2.length) {
        return;
      }
      ptys = [];
      for (i = _i = 0, _len = ptys1.length; _i < _len; i = ++_i) {
        pty1 = ptys1[i];
        if (!(pty = unify(types, pty1, ptys2[i]))) {
          return;
        }
        ptys.push(pty);
      }
      if (rty = unify(types, ty1.ret, ty2.ret)) {
        return new ArrowType(ptys, rty);
      }
    }
    return null;
  };

  Base.prototype.computeType = function(r, o) {};

  Literal.prototype.computeType = function(r, o) {
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    return this.computedType = this.value === 'null' ? anyPtrTy : this.isAssignable() ? o.scope.typeOf(this.value) : this.isSimpleNumber() ? intTy : void 0;
  };

  Assign.prototype.computeType = function(r, o) {
    var lhTy, rhTy;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    if (!(lhTy = this.variable.unwrapAll().computeType(r, o))) {
      return;
    }
    rhTy = this.value.unwrapAll().computeType(r, o);
    if (!rhTy) {
      throw TypeError('cannot assign untyped to typed');
    }
    if (!(this.computedType = unify(o.types, lhTy, rhTy))) {
      throw TypeError("incompatible types in assignment: `" + lhTy + "' and `" + rhTy + "'");
    }
  };

  Value.prototype.computeType = function(r, o) {
    var baseTy, field, fieldName, prop, _i, _len, _ref2;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    if (baseTy = this.base.unwrapAll().computeType(r, o)) {
      _ref2 = this.properties;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        prop = _ref2[_i];
        if (baseTy instanceof PointerType) {
          baseTy = baseTy.base;
        }
        if (!(baseTy instanceof StructType)) {
          return;
        }
        if (prop.soak) {
          throw TypeError("cannot soak struct field names");
        }
        fieldName = prop.name.unwrapAll().value;
        field = prop.computedField = baseTy.names[fieldName];
        if (!field) {
          throw TypeError("unknown struct field name `" + fieldName + "'");
        }
        baseTy = field.type;
      }
      return this.computedType = baseTy;
    }
  };

  Code.prototype.computeType = function(r, o) {
    var rty, ty, types, _i, _len, _ref2;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    types = o.types;
    rty = null;
    _ref2 = returnExpressions(this.body);
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      ty = _ref2[_i];
      rty = unify(types, ty.computedType, rty);
    }
    return this.computedType = new ArrowType(this.paramTypes, rty);
  };

  Op.prototype.computeType = function(r, o) {
    var ARITH_OPS, first, op, primTys, tmp, ty1, ty2;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    op = this.operator;
    if (this.isUnary()) {
      first = this.first.unwrapAll();
      return this.computedType = (function() {
        if (op === 'new' && (ty1 = o.types[first.value])) {
          if (!ty1.size) {
            throw TypeError('cannot allocate type with size 0');
          }
          return new PointerType(ty1);
        } else if (op === 'delete' && (ty1 = first.computeType(r, o))) {
          if (!(ty1 instanceof PointerType)) {
            throw TypeError('cannot free non-pointer type');
          }
          if (ty1.onStack) {
            throw TypeError('cannot free on-stack variables');
          }
          return unitTy;
        }
      })();
    }
    ty1 = this.first.unwrapAll().computeType(r, o);
    ty2 = this.second.unwrapAll().computeType(r, o);
    if (ty2 instanceof PointerType) {
      tmp = ty1;
      ty1 = ty2;
      ty2 = tmp;
    }
    ARITH_OPS = ['+', '-', '*', '/', '<<', '>>', '>>>', '~', '&', '|'];
    primTys = [byteTy, shortTy, intTy, uintTy];
    return this.computedType = op === '+' && ty1 instanceof PointerType && __indexOf.call(primTys, ty2) >= 0 ? ty1 : op === '-' && ty1 instanceof PointerType && ty2 instanceof PointerType ? unify(o.types, ty1.base, ty2.base) ? intTy : void 0 : __indexOf.call(ARITH_OPS, op) >= 0 && __indexOf.call(primTys, ty1) >= 0 && __indexOf.call(primTys, ty2) >= 0 ? intTy : void 0;
  };

  Ref.prototype.computeType = function(r, o) {
    var ty;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    ty = this.expr.unwrapAll().computeType(r, o);
    if (!ty) {
      throw TypeError("taking reference of an untyped expression:\n" + this.expr);
    }
    if (ty instanceof ArrowType) {
      throw TypeError("taking reference of a function type");
    }
    return this.computedType = new PointerType(ty);
  };

  Deref.prototype.computeType = function(r, o) {
    var ty;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    ty = this.expr.unwrapAll().computeType(r, o);
    if (!ty) {
      throw TypeError("dereferencing an untyped expression:\n" + this.expr);
    }
    if (!(ty instanceof PointerType && !ty.onStack)) {
      throw TypeError("dereferencing a non-pointer type");
    }
    return this.computedType = ty.base;
  };

  returnExpressions = function(body) {
    var exprs;
    exprs = body.expressions;
    return body.foldChildren([exprs[exprs.length - 1]], 'returnExpression', null, {});
  };

  Return.prototype.returnExpression = function(exprs, o) {
    exprs.push(this.expression);
    return exprs;
  };

  newTypedScope = function(p, e, m) {
    var scope;
    scope = new Scope(p, e, m);
    scope.variables.length = 0;
    return scope;
  };

  Assign.prototype.primeComputeType = function(r, o) {
    var fn, name, ty;
    if ((fn = this.value.unwrapAll()) instanceof Code && (name = this.variable.unwrapAll()) instanceof Literal && name.isAssignable() && (ty = o.scope.typeOf(name.value)) instanceof ArrowType) {
      if (fn.paramTypes == null) {
        fn.paramTypes = ty.params;
      }
      if (fn.returnType == null) {
        fn.returnType = ty.ret;
      }
    }
  };

  Code.prototype.primeComputeType = function(r, o) {
    var i, name, ptys, rexpr, rty, types, _i, _j, _len, _len1, _ref2, _ref3;
    rty = this.returnType;
    if (rty instanceof ArrowType) {
      _ref2 = returnExpressions(this.body);
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        rexpr = _ref2[_i];
        if (!(rexpr instanceof Code)) {
          continue;
        }
        if (rexpr.paramTypes == null) {
          rexpr.paramTypes = rty.params;
        }
        if (rexpr.returnType == null) {
          rexpr.returnType = rty.ret;
        }
      }
    }
    o.scope = newTypedScope(o.scope, this.body, this);
    ptys = this.paramTypes;
    if (ptys) {
      if (ptys.length !== this.params.length) {
        throw TypeError("arrow type has different number of parameters than function");
      }
      types = o.types;
      _ref3 = this.params;
      for (i = _j = 0, _len1 = _ref3.length; _j < _len1; i = ++_j) {
        name = _ref3[i].name;
        if (!(name instanceof Literal)) {
          throw TypeError("cannot type complex parameter `" + name + "'");
        }
        ptys[i] = ptys[i].lint(types);
        (new DeclareType(new Value(name), ptys[i])).primeComputeType(r, o);
      }
    }
  };

  DeclareType.prototype.primeComputeType = function(r, o) {
    var name, scope, type;
    type = this.type.lint(o.types);
    if (type instanceof StructType) {
      type = new PointerType(type, true);
    }
    name = this.variable.unwrapAll().value;
    scope = o.scope;
    if (scope.check(name)) {
      throw TypeError("cannot redeclare typed variable `" + name + "'");
    }
    scope.add(this.variable.unwrapAll().value, type);
  };

  makeDeref = function(base, offset, ty) {
    var offsetOp;
    if (!ty.view) {
      throw TypeError("unknown view on type `" + ty + "'");
    }
    if (offset !== 0) {
      offsetOp = new Op('+', base, new Value(new Literal(offset)));
    } else {
      offsetOp = base;
    }
    return new Value(ty.view, [new Index(new Op('>>', offsetOp, new Literal(shiftBy(ty.size))))]);
  };

  inlineMemcpy = function(dest, src, n, ret, o) {
    var destPtr, endVal, loopBody, memcpy, scope, srcPtr, stmts;
    scope = o.scope;
    stmts = [];
    destPtr = new Value(new Literal(scope.freeVariable('dest')));
    stmts.push(new Assign(destPtr, dest));
    srcPtr = new Value(new Literal(scope.freeVariable('src')));
    stmts.push(new Assign(srcPtr, src));
    endVal = new Op('+', destPtr, new Literal(n));
    loopBody = new Assign(new Value(HEAP, [new Index(new Op('++', destPtr, null, true))]), new Value(HEAP, [new Index(new Op('++', srcPtr, null, true))]));
    memcpy = new While(new Op('<', destPtr, endVal));
    memcpy.addBody(new Block([loopBody]));
    stmts.push(memcpy);
    stmts.push(ret);
    return new Value(new Parens(new Block(stmts)));
  };

  structLiteral = function(v, ty, o) {
    var access, field, fname, obj, propList, propValue, ptr, _i, _len, _ref2;
    ptr = new Literal(o.scope.freeVariable('ptr'));
    propList = [];
    _ref2 = ty.fields;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      field = _ref2[_i];
      fname = field.name;
      access = new Access(new Literal(fname));
      access.computedField = field;
      propValue = new Value(ptr, [access]);
      propValue.computedType = field.type;
      propList.push(new Assign(new Value(new Literal(fname)), propValue.transform(), 'object'));
    }
    obj = new Value(new Obj(propList));
    return new Value(new Parens(new Block([new Assign(new Value(ptr), v), obj])));
  };

  Value.prototype.transform = function(o) {
    var cumulativeOffset, field, inner, prop, props, ty, v, _i, _len;
    props = this.properties;
    if (!(this.computedType && props.length)) {
      return;
    }
    v = (inner = this.base.unwrapAll()) instanceof Deref ? inner.expr : this.base;
    cumulativeOffset = 0;
    for (_i = 0, _len = props.length; _i < _len; _i++) {
      prop = props[_i];
      field = prop.computedField;
      if ((ty = field.type) instanceof StructType) {
        cumulativeOffset += field.offset;
      } else {
        v = makeDeref(v, field.offset + cumulativeOffset, ty);
        cumulativeOffset = 0;
      }
    }
    if (ty instanceof StructType && cumulativeOffset !== 0) {
      return new Op('+', v, new Value(new Literal(cumulativeOffset)));
    } else {
      return v;
    }
  };

  Assign.prototype.transform = function(o) {
    var lval, ty;
    lval = this.variable;
    ty = this.computedType;
    if (!(lval instanceof Deref && ty instanceof StructType)) {
      return;
    }
    return new Call(MEMCPY, [HEAPV, lval.expr, this.value, new Literal(ty.size)]);
  };

  Op.prototype.transform = function(o) {
    var m, op, ty;
    op = this.operator;
    if (op === 'new' && (ty = this.computedType)) {
      m = ty.onStack ? STACKV : HEAPV;
      return new Call(MALLOC, [m, new Value(new Literal(ty.base.size))]);
    } else if (op === 'delete' && this.first.computedType) {
      return new Call(FREE, [HEAPV, this.first]);
    } else if (this.computedType && !this.isUnary()) {
      if (op === '+' && (ty = this.first.computedType) instanceof PointerType) {
        return new Op('+', this.first, new Op('*', this.second, new Literal(ty.base.size)));
      } else if (op === '+' && (ty = this.second.computedType) instanceof PointerType) {
        return new Op('+', new Op('*', this.first, new Literal(ty.base.size)), this.second);
      } else if (op === '-' && (ty = this.first.computedType) instanceof PointerType) {
        this.transform = null;
        return new Op('>>', this, new Literal(shiftBy(ty.base.size)));
      }
    }
  };

  Ref.prototype.transform = function(o) {
    return this.expr;
  };

  Deref.prototype.transform = function(o) {
    return makeDeref(this.expr, 0, this.expr.computedType);
  };

  PointerType.prototype.view = U32H;

  PrimitiveType = (function() {

    function PrimitiveType(size, debugName, view) {
      this.size = size;
      this.debugName = debugName;
      this.view = view;
    }

    PrimitiveType.prototype.lint = function(types) {
      return this;
    };

    PrimitiveType.prototype.toString = function() {
      return this.debugName;
    };

    return PrimitiveType;

  })();

  anyPtrTy = new PrimitiveType(0, '*');

  unitTy = new PrimitiveType(0, '()');

  byteTy = new PrimitiveType(1, 'byte', HEAP);

  shortTy = new PrimitiveType(2, 'short', I16H);

  intTy = new PrimitiveType(4, 'int', I32H);

  uintTy = new PrimitiveType(4, 'uint', U32H);

  primitiveTypes = {
    byte: byteTy,
    short: shortTy,
    int: intTy,
    uint: uintTy
  };

  exports.analyzeTypes = function(root) {
    var name, options, ty, types;
    if (!root.containsType(DeclareType)) {
      return;
    }
    types = root.foldChildren(primitiveTypes, 'collectType', null, {
      immediate: true
    });
    for (name in types) {
      ty = types[name];
      types[name] = ty.lint(types);
    }
    options = {
      types: types,
      scope: newTypedScope(null, root, null),
      crossScope: true
    };
    root.foldChildren(null, 'primeComputeType', 'computeType', options);
    return types;
  };

}).call(this);
