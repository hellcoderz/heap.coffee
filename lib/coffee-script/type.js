// Generated by CoffeeScript 1.3.1
(function() {
  var ArrowType, Assign, Base, Block, Call, Code, DeclareType, Deref, FREE, HEAP, HEAPV, Index, Literal, MALLOC, Op, PointerType, PrimitiveType, Ref, Return, STACK, STACKV, Scope, StructType, TypeAssign, TypeName, Value, anyPtrTy, byteTy, extend, flatten, intTy, newTypedScope, primitiveTypes, returnExpressions, shortTy, uintTy, unify, unitTy, _ref, _ref1,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Scope = require('./scope').Scope;

  _ref = require('./nodes'), Base = _ref.Base, Block = _ref.Block, Value = _ref.Value, Literal = _ref.Literal, Op = _ref.Op, Assign = _ref.Assign, Code = _ref.Code, Index = _ref.Index, Call = _ref.Call, Return = _ref.Return, TypeAssign = _ref.TypeAssign, DeclareType = _ref.DeclareType, Ref = _ref.Ref, Deref = _ref.Deref, TypeName = _ref.TypeName, PointerType = _ref.PointerType, ArrowType = _ref.ArrowType, StructType = _ref.StructType;

  _ref1 = require('./helpers'), flatten = _ref1.flatten, extend = _ref1.extend;

  HEAP = new Literal('_H');

  HEAPV = new Value(HEAP);

  STACK = new Literal('_S');

  STACKV = new Value(STACK);

  MALLOC = new Literal('_malloc');

  FREE = new Literal('_free');

  Scope.prototype.typeOf = function(name, immediate) {
    var found, _ref2;
    found = this.type(name);
    if (found || immediate) {
      return found;
    }
    return (_ref2 = this.parent) != null ? _ref2.typeOf(name) : void 0;
  };

  Base.prototype.foldChildren = function(r, pre, post, o) {
    var attr, child, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref2, _ref3, _ref4, _ref5;
    r = typeof this[pre] === 'function' ? this[pre](r, o) : r;
    if (!this.children) {
      return r;
    }
    if (o.immediate) {
      _ref2 = this.children;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        attr = _ref2[_i];
        if (this[attr]) {
          _ref3 = flatten([this[attr]]);
          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
            child = _ref3[_j];
            r = typeof child[pre] === 'function' ? child[pre](r, o) : r;
            r = post && typeof child[post] === 'function' ? child[post](r, o) : r;
          }
        }
      }
    } else {
      _ref4 = this.children;
      for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
        attr = _ref4[_k];
        if (this[attr]) {
          _ref5 = flatten([this[attr]]);
          for (_l = 0, _len3 = _ref5.length; _l < _len3; _l++) {
            child = _ref5[_l];
            r = child.foldChildren(r, pre, post, o);
          }
        }
      }
    }
    if (post && typeof this[post] === 'function') {
      return this[post](r, o);
    } else {
      return r;
    }
  };

  Block.prototype.foldChildren = function(r, pre, post, o) {
    return Block.__super__.foldChildren.call(this, r, pre, post, extend({}, o));
  };

  Code.prototype.foldChildren = function(r, pre, post, o) {
    if (!o.crossScope) {
      return r;
    }
    return Code.__super__.foldChildren.call(this, r, pre, post, o);
  };

  TypeAssign.prototype.collectType = function(types) {
    var _base;
    types[this.name] = this.type;
    if ((_base = this.type).debugName == null) {
      _base.debugName = this.name;
    }
    return types;
  };

  TypeName.prototype.lint = function(types) {
    var linted, ty;
    if (this.linting) {
      throw TypeError("circular type synonym: " + this.name);
    }
    if (this.linted) {
      return this.linted;
    }
    this.linting = true;
    if (!(ty = types[this.name])) {
      throw TypeError("cannot resolve type `" + this.name + "'");
    }
    linted = ty.lint(types);
    delete this.linting;
    return this.linted = linted;
  };

  PointerType.prototype.size = 4;

  PointerType.prototype.lint = function(types) {
    if (this.linted) {
      return this;
    }
    this.linted = true;
    this.base = this.base.lint(types);
    if (this.base instanceof ArrowType) {
      throw TypeError("cannot take pointers of function types");
    }
    return this;
  };

  StructType.prototype.lint = function(types) {
    var field, size, _i, _j, _len, _len1, _ref2, _ref3;
    if (this.linted) {
      return this;
    }
    this.linted = true;
    _ref2 = this.fields;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      field = _ref2[_i];
      field.type = field.type.lint(types);
    }
    size = 0;
    _ref3 = this.fields;
    for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
      field = _ref3[_j];
      field.offset = size;
      size += field.type.size;
    }
    this.size = size;
    return this;
  };

  ArrowType.prototype.lint = function(types) {
    var i, params, ty, _i, _len;
    if (this.linted) {
      return this;
    }
    this.linted = true;
    ty = this.ret.lint(types);
    this.ret = ty;
    params = this.params;
    for (i = _i = 0, _len = params.length; _i < _len; i = ++_i) {
      ty = params[i];
      params[i] = ty.lint(types);
    }
    return this;
  };

  unify = function(types, ty1, ty2) {
    var base, i, pty, pty1, ptys, ptys1, ptys2, rty, _i, _len;
    if (ty1 === ty2) {
      return ty1;
    }
    if (!ty2) {
      return ty1;
    }
    if (!ty1) {
      return ty2;
    }
    if (ty1 instanceof PointerType && ty2 === anyPtrTy) {
      return ty1;
    }
    if (ty2 instanceof PointerType && ty1 === anyPtrTy) {
      return ty2;
    }
    if (ty1 instanceof PointerType && ty2 instanceof PointerType) {
      base = unify(types, ty1.base, ty2.base);
      if (base) {
        return new PointerType(base);
      }
    }
    if (ty1 instanceof ArrowType && ty2 instanceof ArrowType) {
      ptys1 = ty1.params;
      ptys2 = ty2.params;
      if (ptys1.length !== ptys2.length) {
        return;
      }
      ptys = [];
      for (i = _i = 0, _len = ptys1.length; _i < _len; i = ++_i) {
        pty1 = ptys1[i];
        if (!(pty = unify(types, pty1, ptys2[i]))) {
          return;
        }
        ptys.push(pty);
      }
      if (rty = unify(types, ty1.ret, ty2.ret)) {
        return new ArrowType(ptys, rty);
      }
    }
    return null;
  };

  Base.prototype.computeType = function(r, o) {};

  Literal.prototype.computeType = function(r, o) {
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    return this.computedType = this.value === 'null' ? anyPtrTy : this.isAssignable() ? o.scope.typeOf(this.value) : this.isSimpleNumber() ? intTy : void 0;
  };

  Assign.prototype.computeType = function(r, o) {
    var lhTy, rhTy;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    if (!(lhTy = this.variable.unwrapAll().computeType(r, o))) {
      return;
    }
    rhTy = this.value.unwrapAll().computeType(r, o);
    if (!rhTy) {
      throw TypeError('cannot assign untyped to typed');
    }
    if (!(this.computedType = unify(o.types, lhTy, rhTy))) {
      throw TypeError("incompatible types in assignment: `" + lhTy + "' and `" + rhTy + "'");
    }
  };

  Value.prototype.computeType = function(r, o) {
    var baseTy, field, fieldName, prop, _i, _len, _ref2;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    if (baseTy = this.base.unwrapAll().computeType(r, o)) {
      _ref2 = this.properties;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        prop = _ref2[_i];
        if (baseTy instanceof PointerType) {
          baseTy = baseTy.base;
        }
        if (!(baseTy instanceof StructType)) {
          return;
        }
        if (prop.soak) {
          throw TypeError("cannot soak struct field names");
        }
        fieldName = prop.name.unwrapAll().value;
        field = baseTy.names[fieldName];
        if (!field) {
          throw TypeError("unknown struct field name `" + fieldName + "'");
        }
        prop.computedOffset = field.offset;
        baseTy = field.type;
      }
      return this.computedType = baseTy;
    }
  };

  Code.prototype.computeType = function(r, o) {
    var rty, ty, types, _i, _len, _ref2;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    types = o.types;
    rty = null;
    _ref2 = returnExpressions(this.body);
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      ty = _ref2[_i];
      rty = unify(types, ty.computedType, rty);
    }
    return this.computedType = new ArrowType(this.paramTypes, rty);
  };

  Op.prototype.computeType = function(r, o) {
    var ARITH_OPS, first, op, primTys, tmp, ty1, ty2;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    op = this.operator;
    if (this.isUnary()) {
      first = this.first.unwrapAll();
      return this.computedType = (function() {
        if (op === 'new' && (ty1 = o.types[first.value])) {
          if (!ty1.size) {
            throw TypeError('cannot allocate type with size 0');
          }
          return new PointerType(ty1);
        } else if (op === 'delete' && (ty1 = first.computeType(r, o))) {
          if (!(ty1 instanceof PointerType)) {
            throw TypeError('cannot free non-pointer type');
          }
          if (ty1.onStack) {
            throw TypeError('cannot free on-stack variables');
          }
          return unitTy;
        }
      })();
    }
    ty1 = this.first.unwrapAll().computeType(r, o);
    ty2 = this.second.unwrapAll().computeType(r, o);
    if (ty2 instanceof PointerType) {
      tmp = ty1;
      ty1 = ty2;
      ty2 = tmp;
    }
    ARITH_OPS = ['+', '-', '*', '/', '<<', '>>', '>>>', '~', '&', '|'];
    primTys = [byteTy, shortTy, intTy, uintTy];
    return this.computedType = op === '+' && ty1 instanceof PointerType && __indexOf.call(primTys, ty2) >= 0 ? ty1 : op === '-' && ty1 instanceof PointerType && ty2 instanceof PointerType ? unify(o.types, ty1.base, ty2.base) ? intTy : void 0 : __indexOf.call(ARITH_OPS, op) >= 0 && __indexOf.call(primTys, ty1) >= 0 && __indexOf.call(primTys, ty2) >= 0 ? intTy : void 0;
  };

  Ref.prototype.computeType = function(r, o) {
    var ty;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    ty = this.expr.unwrapAll().computeType(r, o);
    if (!ty) {
      throw TypeError("taking reference of an untyped expression:\n" + this.expr);
    }
    if (ty instanceof ArrowType) {
      throw TypeError("taking reference of a function type");
    }
    return this.computedType = new PointerType(ty);
  };

  Deref.prototype.computeType = function(r, o) {
    var ty;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    ty = this.expr.unwrapAll().computeType(r, o);
    if (!ty) {
      throw TypeError("dereferencing an untyped expression:\n" + this.expr);
    }
    if (!(ty instanceof PointerType && !ty.onStack)) {
      throw TypeError("dereferencing a non-pointer type");
    }
    return this.computedType = ty.base;
  };

  returnExpressions = function(body) {
    var exprs;
    exprs = body.expressions;
    return body.foldChildren([exprs[exprs.length - 1]], 'returnExpression', null, {});
  };

  Return.prototype.returnExpression = function(exprs, o) {
    exprs.push(this.expression);
    return exprs;
  };

  newTypedScope = function(p, e, m) {
    var scope;
    scope = new Scope(p, e, m);
    scope.variables.length = 0;
    return scope;
  };

  Assign.prototype.primeComputeType = function(r, o) {
    var fn, name, ty;
    if ((fn = this.value.unwrapAll()) instanceof Code && (name = this.variable.unwrapAll()) instanceof Literal && name.isAssignable() && (ty = o.scope.typeOf(name.value)) instanceof ArrowType) {
      if (fn.paramTypes == null) {
        fn.paramTypes = ty.params;
      }
      if (fn.returnType == null) {
        fn.returnType = ty.ret;
      }
    }
  };

  Code.prototype.primeComputeType = function(r, o) {
    var i, name, ptys, rexpr, rty, types, _i, _j, _len, _len1, _ref2, _ref3;
    rty = this.returnType;
    if (rty instanceof ArrowType) {
      _ref2 = returnExpressions(this.body);
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        rexpr = _ref2[_i];
        if (!(rexpr instanceof Code)) {
          continue;
        }
        if (rexpr.paramTypes == null) {
          rexpr.paramTypes = rty.params;
        }
        if (rexpr.returnType == null) {
          rexpr.returnType = rty.ret;
        }
      }
    }
    o.scope = newTypedScope(o.scope, this.body, this);
    ptys = this.paramTypes;
    if (ptys) {
      if (ptys.length !== this.params.length) {
        throw TypeError("arrow type has different number of parameters than function");
      }
      types = o.types;
      _ref3 = this.params;
      for (i = _j = 0, _len1 = _ref3.length; _j < _len1; i = ++_j) {
        name = _ref3[i].name;
        if (!(name instanceof Literal)) {
          throw TypeError("cannot type complex parameter `" + name + "'");
        }
        ptys[i] = ptys[i].lint(types);
        (new DeclareType(new Value(name), ptys[i])).primeComputeType(r, o);
      }
    }
  };

  DeclareType.prototype.primeComputeType = function(r, o) {
    var name, scope;
    this.type = this.type.lint(o.types);
    if (this.type instanceof StructType) {
      this.type = new PointerType(this.type, true);
    }
    name = this.variable.unwrapAll().value;
    scope = o.scope;
    if (scope.check(name)) {
      throw TypeError("cannot redeclare typed variable `" + name + "'");
    }
    scope.add(this.variable.unwrapAll().value, this.type);
  };

  Value.prototype.transform = function() {
    var getExpr, heapOffset, inner, props;
    props = this.properties;
    if (!(this.computedType && props.length)) {
      return;
    }
    heapOffset = function(idx, prop) {
      return new Value(HEAP, [new Index(new Op('+', idx, new Value(new Literal(prop.computedOffset))))]);
    };
    getExpr = function() {
      return this.expr;
    };
    inner = this.base.unwrapAll();
    if (inner instanceof Deref) {
      inner.transform = getExpr;
    }
    return props.reduce(heapOffset, this.base);
  };

  Op.prototype.transform = function() {
    var m, op, ty;
    op = this.operator;
    if (op === 'new' && (ty = this.computedType)) {
      m = ty.onStack ? STACKV : HEAPV;
      return new Call(new Value(MALLOC), [m, new Value(new Literal(ty.base.size))]);
    } else if (op === 'delete' && this.first.computedType) {
      return new Call(new Value(FREE), [HEAPV, this.first]);
    } else if (this.computedType && !this.isUnary()) {
      if (op === '+' && (ty = this.first.computedType) instanceof PointerType) {
        return new Op('+', this.first, new Op('*', this.second, new Literal(ty.base.size)));
      } else if (op === '+' && (ty = this.second.computedType) instanceof PointerType) {
        return new Op('+', new Op('*', this.first, new Literal(ty.base.size)), this.second);
      } else if (op === '-' && (ty = this.first.computedType) instanceof PointerType) {
        this.transform = null;
        return new Op('>>', this, new Literal(Math.log(ty.base.size) / Math.log(2)));
      }
    }
  };

  Ref.prototype.transform = function() {
    return this.expr;
  };

  Deref.prototype.transform = function() {
    return new Value(HEAP, [new Index(this.expr)]);
  };

  PrimitiveType = (function() {

    function PrimitiveType(size, debugName) {
      this.size = size;
      this.debugName = debugName;
    }

    PrimitiveType.prototype.lint = function(types) {
      return this;
    };

    PrimitiveType.prototype.toString = function() {
      return this.debugName;
    };

    return PrimitiveType;

  })();

  anyPtrTy = new PrimitiveType(0, '*');

  unitTy = new PrimitiveType(0, '()');

  byteTy = new PrimitiveType(1, 'byte');

  shortTy = new PrimitiveType(2, 'short');

  intTy = new PrimitiveType(4, 'int');

  uintTy = new PrimitiveType(4, 'uint');

  primitiveTypes = {
    byte: byteTy,
    short: shortTy,
    int: intTy,
    uint: uintTy
  };

  exports.analyzeTypes = function(root) {
    var name, options, ty, types;
    if (!root.containsType(DeclareType)) {
      return;
    }
    types = root.foldChildren(primitiveTypes, 'collectType', null, {
      immediate: true
    });
    for (name in types) {
      ty = types[name];
      types[name] = ty.lint(types);
    }
    options = {
      types: types,
      scope: newTypedScope(null, root, null),
      crossScope: true
    };
    root.foldChildren(null, 'primeComputeType', 'computeType', options);
    return types;
  };

}).call(this);
