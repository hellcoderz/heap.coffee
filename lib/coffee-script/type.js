// Generated by CoffeeScript 1.3.1
(function() {
  var Access, ArrowType, Assign, Base, Block, Call, Cast, Code, DeclareType, FREE, HEAP, HEAPV, I16H, I32H, Index, Literal, MALLOC, MEMCPY, Obj, Op, Parens, PointerType, PrimitiveType, Return, STACK, STACKV, Scope, StructType, TypeAssign, TypeName, U16H, U32H, Value, While, anyPtrTy, byteTy, extend, flatten, inlineMemcpy, intTy, makeDeref, newTypedScope, offsetExpr, opts, primTys, printWarn, returnExpressions, shortTy, structLiteral, tystr, uintTy, unify, _ref, _ref1,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Scope = require('./scope').Scope;

  _ref = require('./nodes'), Base = _ref.Base, Parens = _ref.Parens, Block = _ref.Block, Value = _ref.Value, Literal = _ref.Literal, Op = _ref.Op, Assign = _ref.Assign, Code = _ref.Code, Index = _ref.Index, Access = _ref.Access, Call = _ref.Call, Return = _ref.Return, Obj = _ref.Obj, While = _ref.While, TypeAssign = _ref.TypeAssign, DeclareType = _ref.DeclareType, Cast = _ref.Cast, TypeName = _ref.TypeName, PointerType = _ref.PointerType, ArrowType = _ref.ArrowType, StructType = _ref.StructType;

  _ref1 = require('./helpers'), flatten = _ref1.flatten, extend = _ref1.extend, tystr = _ref1.tystr;

  HEAP = new Literal('H');

  HEAPV = new Value(HEAP);

  STACK = new Literal('S');

  STACKV = new Value(STACK);

  I16H = new Literal('I16H');

  U16H = new Literal('U16H');

  I32H = new Literal('I32H');

  U32H = new Literal('U32H');

  MALLOC = new Value(new Literal('malloc'));

  FREE = new Value(new Literal('free'));

  MEMCPY = new Value(new Literal('memcpy'));

  opts = {
    warn: false
  };

  printWarn = function(line) {
    if (opts.warn) {
      return process.stderr.write('warning: ' + line + '\n');
    }
  };

  offsetExpr = function(base, offset, size) {
    var op, shiftBy;
    op = offset !== 0 ? new Op('+', base, new Value(new Literal(offset))) : base;
    shiftBy = Math.log(size) / Math.log(2);
    if (shiftBy !== 0) {
      return new Op('>>', op, new Literal(shiftBy));
    } else {
      return op;
    }
  };

  Scope.prototype.typeOf = function(name, immediate) {
    var found, _ref2;
    found = this.type(name);
    if (found || immediate) {
      return found;
    }
    return (_ref2 = this.parent) != null ? _ref2.typeOf(name) : void 0;
  };

  Base.prototype.foldChildren = function(r, pre, post, o) {
    var attr, child, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref2, _ref3, _ref4, _ref5;
    r = typeof this[pre] === 'function' ? this[pre](r, o) : r;
    if (!this.children) {
      return r;
    }
    if (o.immediate) {
      _ref2 = this.children;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        attr = _ref2[_i];
        if (this[attr]) {
          _ref3 = flatten([this[attr]]);
          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
            child = _ref3[_j];
            r = typeof child[pre] === 'function' ? child[pre](r, o) : r;
            r = post && typeof child[post] === 'function' ? child[post](r, o) : r;
          }
        }
      }
    } else {
      _ref4 = this.children;
      for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
        attr = _ref4[_k];
        if (this[attr]) {
          _ref5 = flatten([this[attr]]);
          for (_l = 0, _len3 = _ref5.length; _l < _len3; _l++) {
            child = _ref5[_l];
            r = child.foldChildren(r, pre, post, o);
          }
        }
      }
    }
    if (post && typeof this[post] === 'function') {
      return this[post](r, o);
    } else {
      return r;
    }
  };

  Block.prototype.foldChildren = function(r, pre, post, o) {
    return Block.__super__.foldChildren.call(this, r, pre, post, extend({}, o));
  };

  Code.prototype.foldChildren = function(r, pre, post, o) {
    if (!o.crossScope) {
      return r;
    }
    return Code.__super__.foldChildren.call(this, r, pre, post, o);
  };

  TypeAssign.prototype.collectType = function(types) {
    types[this.name] = this.type;
    return types;
  };

  TypeName.prototype.lint = function(types) {
    var linted, _ref2;
    if (this.linting) {
      throw TypeError("circular type synonym: " + this.name);
    }
    if (this.linted) {
      return this.linted;
    }
    this.linting = true;
    if (!(this.name in types)) {
      throw TypeError("cannot resolve type `" + this.name + "'");
    }
    linted = (_ref2 = types[this.name]) != null ? _ref2.lint(types) : void 0;
    delete this.linting;
    return this.linted = linted;
  };

  PointerType.prototype.size = 4;

  PointerType.prototype.lint = function(types) {
    if (this.linted) {
      return this;
    }
    this.linted = true;
    this.base = this.base.lint(types);
    if (this.base instanceof ArrowType) {
      throw TypeError("cannot take pointers of function types");
    }
    return this;
  };

  StructType.prototype.lint = function(types) {
    var field, fields, offset, prev, s, size, _i, _j, _len, _len1;
    if (this.linted) {
      return this;
    }
    this.linted = true;
    fields = this.fields;
    for (_i = 0, _len = fields.length; _i < _len; _i++) {
      field = fields[_i];
      field.type = field.type.lint(types);
    }
    prev = {
      offset: 0,
      type: {
        size: 0
      }
    };
    size = 0;
    for (_j = 0, _len1 = fields.length; _j < _len1; _j++) {
      field = fields[_j];
      if ((offset = field.offset) != null) {
        if (offset < 0) {
          throw TypeError("struct field offsets cannot be negative");
        }
        if (offset < prev.offset) {
          printWarn("offset of field `" + field.name + "' is smaller offset of previous field");
        }
      } else if (field.usePreviousOffset) {
        field.offset = prev.offset;
      } else {
        field.offset = prev.offset + prev.type.size;
      }
      if ((s = field.offset + field.type.size) > size) {
        size = s;
      }
      prev = field;
    }
    this.size = size;
    return this;
  };

  ArrowType.prototype.lint = function(types) {
    var i, params, ty, _i, _len;
    if (this.linted) {
      return this;
    }
    this.linted = true;
    ty = this.ret.lint(types);
    this.ret = ty;
    params = this.params;
    for (i = _i = 0, _len = params.length; _i < _len; i = ++_i) {
      ty = params[i];
      params[i] = ty.lint(types);
    }
    return this;
  };

  unify = function(types, lty, rty, assign) {
    var i, lpty, lptys, pty, ptys, ret, rptys, _i, _len;
    if (lty === rty) {
      return lty;
    }
    if (!(lty && rty)) {
      return;
    }
    if (lty instanceof PointerType && rty instanceof PointerType) {
      if (assign && !rty.base) {
        return lty;
      }
      return new PointerType(unify(types, lty.base, rty.base));
    }
    if (lty instanceof ArrowType && rty instanceof ArrowType) {
      lptys = lty.params;
      rptys = rty.params;
      if (lptys.length !== rptys.length) {
        return;
      }
      ptys = [];
      for (i = _i = 0, _len = lptys.length; _i < _len; i = ++_i) {
        lpty = lptys[i];
        if (!(pty = unify(types, lpty, rptys[i]))) {
          return;
        }
        ptys.push(pty);
      }
      if (ret = unify(types, lty.ret, rty.ret)) {
        return new ArrowType(ptys, ret);
      }
    }
    if (lty instanceof PointerType && __indexOf.call(primTys, rty) >= 0) {
      printWarn("conversion from `" + rty + "' to pointer without cast");
      return lty;
    }
    if (__indexOf.call(primTys, lty) >= 0 && rty instanceof PointerType) {
      printWarn("conversion from pointer to `" + lty + "' without cast");
      return lty;
    }
    if (__indexOf.call(primTys, lty) >= 0 && __indexOf.call(primTys, rty) >= 0) {
      if (lty.size !== rty.size) {
        printWarn("conversion from `" + rty + "' to `" + lty + "' may alter its value");
        if (assign) {
          return lty;
        } else if (lty.size > rty.size) {
          return lty;
        } else {
          return rty;
        }
      }
      if (lty.signed !== rty.signed) {
        printWarn("conversion from `" + rty + "' to `" + lty + "' may alter its sign");
        return lty;
      }
    }
    return null;
  };

  Op.prototype.isDeref = function() {
    return !this.second && this.operator === '*';
  };

  Base.prototype.computeType = function(r, o) {};

  Cast.prototype.computeType = function(r, o) {
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    return this.computedType = this.type.lint(o.types);
  };

  Literal.prototype.computeType = function(r, o) {
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    return this.computedType = this.value === 'null' ? anyPtrTy : this.isAssignable() ? o.scope.typeOf(this.value) : this.isSimpleNumber() ? intTy : void 0;
  };

  Assign.prototype.computeType = function(r, o) {
    var lty, rty, value;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    if (!(lty = this.variable.unwrapAll().computedType)) {
      return;
    }
    value = this.value.unwrapAll();
    if (lty instanceof PointerType && value instanceof Literal && value.value === '0') {
      value.computedType = anyPtrTy;
    }
    rty = value.computedType;
    if (!(this.computedType = unify(o.types, lty, rty, true))) {
      throw TypeError("incompatible types: assigning `" + (tystr(rty)) + "' to `" + lty + "'");
    }
  };

  Value.prototype.computeType = function(r, o) {
    var baseTy, field, fieldName, prop, _i, _len, _ref2;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    if (baseTy = this.base.unwrapAll().computedType) {
      _ref2 = this.properties;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        prop = _ref2[_i];
        if (baseTy instanceof PointerType) {
          baseTy = baseTy.base;
        }
        if (!(baseTy instanceof StructType)) {
          return;
        }
        if (prop.soak) {
          throw TypeError("cannot soak struct field names");
        }
        fieldName = prop.name.unwrapAll().value;
        field = prop.computedField = baseTy.names[fieldName];
        if (!field) {
          throw TypeError("unknown struct field name `" + fieldName + "'");
        }
        baseTy = field.type;
      }
      return this.computedType = baseTy;
    }
  };

  Code.prototype.computeType = function(r, o) {
    var rexpr, rty, types, _i, _len, _ref2;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    types = o.types;
    rty = null;
    _ref2 = returnExpressions(this.body);
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      rexpr = _ref2[_i];
      rty = unify(types, rexpr.computedType, rty);
    }
    return this.computedType = new ArrowType(this.paramTypes, rty);
  };

  Op.prototype.computeType = function(r, o) {
    var ARITH_OPS, BITWISE_OPS, first, op, tmp, ty1, ty2;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    op = this.operator;
    if (this.isUnary()) {
      first = this.first.unwrapAll();
      return this.computedType = (function() {
        if (op === 'new' && first.value in o.types) {
          ty1 = o.types[first.value];
          if (!(ty1 != null ? ty1.size : void 0)) {
            throw TypeError('cannot allocate type with size 0');
          }
          return new PointerType(ty1);
        } else if (op === 'delete' && (ty1 = first.computedType)) {
          if (!(ty1 instanceof PointerType)) {
            throw TypeError('cannot free non-pointer type');
          }
          if (ty1.onStack) {
            throw TypeError('cannot free on-stack variables');
          }
          return unitTy;
        } else if (op === 'sizeof') {
          ty1 = o.types[first.value];
          if (!ty1) {
            throw TypeError("cannot determine size of type `" + first.value + "'");
          }
          this.first = ty1;
          return intTy;
        } else if (op === '&' && (ty1 = first.computedType)) {
          if (!ty1) {
            throw TypeError("taking reference of an untyped expression:\n" + this.first);
          }
          if (ty1 instanceof ArrowType1) {
            throw TypeError("taking reference of a function type");
          }
          return new PointerType(ty1);
        } else if (op === '*' && (ty1 = first.computedType)) {
          if (!ty1) {
            throw TypeError("dereferencing an untyped expression:\n" + this.expr);
          }
          if (!(ty1 instanceof PointerType && !ty1.onStack)) {
            throw TypeError("dereferencing a non-pointer type");
          }
          return ty1.base;
        }
      }).call(this);
    }
    ty1 = this.first.unwrapAll().computedType;
    ty2 = this.second.unwrapAll().computedType;
    if (ty2 instanceof PointerType) {
      tmp = ty1;
      ty1 = ty2;
      ty2 = tmp;
    }
    ARITH_OPS = ['+', '-', '*', '/'];
    BITWISE_OPS = ['<<', '>>', '>>>', '~', '&', '|'];
    return this.computedType = op === '+' && ty1 instanceof PointerType && __indexOf.call(primTys, ty2) >= 0 ? ty1 : op === '-' && ty1 instanceof PointerType && ty2 instanceof PointerType ? unify(o.types, ty1.base, ty2.base) ? intTy : void 0 : op === '%' ? intTy : __indexOf.call(BITWISE_OPS, op) >= 0 ? ty1 : __indexOf.call(ARITH_OPS, op) >= 0 && __indexOf.call(primTys, ty1) >= 0 && __indexOf.call(primTys, ty2) >= 0 ? unify(o.types, ty1, ty2) : void 0;
  };

  returnExpressions = function(body) {
    var exprs;
    exprs = body.expressions;
    return body.foldChildren([exprs[exprs.length - 1]], 'returnExpression', null, {});
  };

  Return.prototype.returnExpression = function(exprs, o) {
    exprs.push(this.expression);
    return exprs;
  };

  newTypedScope = function(p, e, m) {
    var scope;
    scope = new Scope(p, e, m);
    scope.variables.length = 0;
    return scope;
  };

  Assign.prototype.primeComputeType = function(r, o) {
    var fn, name, ty;
    if ((fn = this.value.unwrapAll()) instanceof Code && (name = this.variable.unwrapAll()) instanceof Literal && name.isAssignable() && (ty = o.scope.typeOf(name.value)) instanceof ArrowType) {
      if (fn.paramTypes == null) {
        fn.paramTypes = ty.params;
      }
      if (fn.returnType == null) {
        fn.returnType = ty.ret;
      }
    }
  };

  Code.prototype.primeComputeType = function(r, o) {
    var i, name, ptys, rexpr, rty, types, _i, _j, _len, _len1, _ref2, _ref3;
    rty = this.returnType;
    if (rty instanceof ArrowType) {
      _ref2 = returnExpressions(this.body);
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        rexpr = _ref2[_i];
        if (!(rexpr instanceof Code)) {
          continue;
        }
        if (rexpr.paramTypes == null) {
          rexpr.paramTypes = rty.params;
        }
        if (rexpr.returnType == null) {
          rexpr.returnType = rty.ret;
        }
      }
    }
    o.scope = newTypedScope(o.scope, this.body, this);
    ptys = this.paramTypes;
    if (ptys) {
      if (ptys.length !== this.params.length) {
        throw TypeError("arrow type has different number of parameters than function");
      }
      types = o.types;
      _ref3 = this.params;
      for (i = _j = 0, _len1 = _ref3.length; _j < _len1; i = ++_j) {
        name = _ref3[i].name;
        if (!(name instanceof Literal)) {
          throw TypeError("cannot type complex parameter `" + name + "'");
        }
        ptys[i] = ptys[i].lint(types);
        (new DeclareType(new Value(name), ptys[i])).primeComputeType(r, o);
      }
    }
  };

  DeclareType.prototype.primeComputeType = function(r, o) {
    var name, scope, type;
    type = this.type.lint(o.types);
    if (type instanceof StructType) {
      type = new PointerType(type, true);
    }
    name = this.variable.unwrapAll().value;
    scope = o.scope;
    if (scope.check(name)) {
      throw TypeError("cannot redeclare typed variable `" + name + "'");
    }
    scope.add(this.variable.unwrapAll().value, type);
  };

  makeDeref = function(base, offset, ty) {
    if (!ty.view) {
      throw TypeError("unknown view on type `" + ty + "'");
    }
    return new Value(ty.view, [new Index(offsetExpr(base, offset, ty.size))]);
  };

  inlineMemcpy = function(dest, src, ty, o) {
    var access, assign, destProp, destPtr, field, fty, i, offset, scope, srcProp, srcPtr, stmts, _i, _j, _len, _ref2, _ref3;
    scope = o.scope;
    stmts = [];
    destPtr = new Literal(scope.freeVariable('dest'));
    stmts.push(new Assign(new Value(destPtr), dest));
    srcPtr = new Literal(scope.freeVariable('src'));
    stmts.push(new Assign(new Value(srcPtr), src));
    if (ty instanceof StructType) {
      _ref2 = ty.fields;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        field = _ref2[_i];
        access = new Access(new Literal(field.name));
        access.computedField = field;
        fty = field.type;
        destProp = new Value(destPtr, [access]);
        destProp.computedType = fty;
        srcProp = new Value(srcPtr, [access]);
        srcProp.computedType = fty;
        assign = new Assign(destProp, srcProp);
        assign.computedType = fty;
        stmts.push(assign);
      }
    } else {
      for (i = _j = 0, _ref3 = ty.size; 0 <= _ref3 ? _j < _ref3 : _j > _ref3; i = 0 <= _ref3 ? ++_j : --_j) {
        offset = new Value(new Literal(i));
        stmts.push(new Assign(new Value(HEAP, [new Index(new Op('+', new Value(destPtr), offset))]), new Value(HEAP, [new Index(new Op('+', new Value(srcPtr), offset))])));
      }
    }
    stmts.push(new Value(destPtr));
    return new Value(new Parens(new Block(stmts)));
  };

  structLiteral = function(v, ty, o) {
    var access, field, fname, obj, propList, propValue, ptr, _i, _len, _ref2;
    ptr = new Literal(o.scope.freeVariable('ptr'));
    propList = [];
    _ref2 = ty.fields;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      field = _ref2[_i];
      fname = field.name;
      access = new Access(new Literal(fname));
      access.computedField = field;
      propValue = new Value(ptr, [access]);
      propValue.computedType = field.type;
      propList.push(new Assign(new Value(new Literal(fname)), propValue.transform(), 'object'));
    }
    obj = new Value(new Obj(propList));
    return new Value(new Parens(new Block([new Assign(new Value(ptr), v), obj])));
  };

  Value.prototype.transform = function(o) {
    var cumulativeOffset, field, inner, prop, props, ty, v, _base, _i, _len;
    props = this.properties;
    if (!(this.computedType && props.length)) {
      return;
    }
    v = (typeof (_base = (inner = this.base.unwrapAll())).isDeref === "function" ? _base.isDeref() : void 0) ? inner.first : this.base;
    cumulativeOffset = 0;
    for (_i = 0, _len = props.length; _i < _len; _i++) {
      prop = props[_i];
      field = prop.computedField;
      if ((ty = field.type) instanceof StructType) {
        cumulativeOffset += field.offset;
      } else {
        v = makeDeref(v, field.offset + cumulativeOffset, ty);
        cumulativeOffset = 0;
      }
    }
    if (ty instanceof StructType && cumulativeOffset !== 0) {
      return new Op('+', v, new Value(new Literal(cumulativeOffset)));
    } else {
      return v;
    }
  };

  Assign.prototype.transform = function(o) {
    var lval, ty;
    lval = this.variable;
    ty = this.computedType;
    if (!((typeof lval.isDeref === "function" ? lval.isDeref() : void 0) && ty instanceof StructType)) {
      return;
    }
    return inlineMemcpy(lval.first, this.value, ty, o);
  };

  Op.prototype.transform = function(o) {
    var m, op, ty;
    if (!this.computedType) {
      return;
    }
    op = this.operator;
    if (this.isUnary()) {
      if (op === 'new' && (ty = this.computedType)) {
        m = ty.onStack ? STACKV : HEAPV;
        return new Call(MALLOC, [m, new Value(new Literal(ty.base.size))]);
      } else if (op === 'delete') {
        return new Call(FREE, [HEAPV, this.first]);
      } else if (op === 'sizeof') {
        return new Literal(this.first.size);
      } else if (op === '&') {
        return this.first;
      } else if (op === '*') {
        return makeDeref(this.first, 0, this.first.computedType);
      }
    } else {
      if (op === '+' && (ty = this.first.computedType) instanceof PointerType) {
        return new Op('+', this.first, new Op('*', this.second, new Literal(ty.base.size)));
      } else if (op === '+' && (ty = this.second.computedType) instanceof PointerType) {
        return new Op('+', new Op('*', this.first, new Literal(ty.base.size)), this.second);
      } else if (op === '-' && (ty = this.first.computedType) instanceof PointerType) {
        this.transform = null;
        return offsetExpr(this, 0, ty.base.size);
      }
    }
  };

  PointerType.prototype.view = U32H;

  PrimitiveType = (function() {

    function PrimitiveType(size, debugName, view, signed) {
      this.size = size;
      this.debugName = debugName;
      this.view = view;
      this.signed = signed;
    }

    PrimitiveType.prototype.lint = function(types) {
      return this;
    };

    PrimitiveType.prototype.toString = function() {
      return this.debugName;
    };

    return PrimitiveType;

  })();

  anyPtrTy = new PointerType(null);

  byteTy = new PrimitiveType(1, 'byte', HEAP, true);

  shortTy = new PrimitiveType(2, 'short', I16H, true);

  intTy = new PrimitiveType(4, 'int', I32H, true);

  uintTy = new PrimitiveType(4, 'uint', U32H, false);

  primTys = [byteTy, shortTy, intTy, uintTy];

  exports.analyzeTypes = function(root, o) {
    var initialTypes, name, options, ty, types;
    if (!root.containsType(DeclareType)) {
      return;
    }
    opts.warn = o.warn;
    initialTypes = {
      any: null,
      byte: byteTy,
      short: shortTy,
      int: intTy,
      uint: uintTy
    };
    types = root.foldChildren(initialTypes, 'collectType', null, {
      immediate: true
    });
    for (name in types) {
      ty = types[name];
      if (ty) {
        types[name] = ty.lint(types);
      }
    }
    options = {
      types: types,
      scope: newTypedScope(null, root, null),
      crossScope: true
    };
    root.foldChildren(null, 'primeComputeType', 'computeType', options);
    return types;
  };

}).call(this);
