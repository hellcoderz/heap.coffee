// Generated by CoffeeScript 1.3.1
(function() {
  var ARITH, Access, Arr, ArrowType, Assign, BITWISE, Base, Binding, Block, COMPARE, Call, Cast, Code, Comment, DeclareType, F32, F32V, F64, F64V, FREE, HEAP, I16, I16V, I32, I32V, I8, I8V, If, Index, Literal, MALLOC, MEMCPY, Obj, Op, Param, Parens, PointerType, PrimitiveType, Return, SP, SPREAL, Scope, StructType, Switch, Try, TypeArr, TypeAssign, TypeName, TypeObj, U16, U16V, U32, U32V, U8, U8V, Value, While, alignOffset, alignmentUnits, anyPtrTy, binopType, coerceIntegral, declare, error, extend, f64ty, flatten, freshVariable, i16ty, i32ty, i8ty, inlineMemcpy, integral, makeDeref, multExpr, newTypedScope, normalizePtr, numeric, offsetExpr, opts, printWarn, putOnStack, recorderForView, requireExpr, returnExpressions, spOffsets, stackFence, stackOffsetExpr, structLiteral, tystr, u16ty, u32ty, u8ty, undefExpr, unify, _ref, _ref1,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Scope = require('./scope').Scope;

  _ref = require('./nodes'), Base = _ref.Base, Parens = _ref.Parens, Block = _ref.Block, Value = _ref.Value, Literal = _ref.Literal, Op = _ref.Op, Assign = _ref.Assign, Try = _ref.Try, If = _ref.If, Switch = _ref.Switch, Param = _ref.Param, Code = _ref.Code, Index = _ref.Index, Access = _ref.Access, Call = _ref.Call, Return = _ref.Return, Obj = _ref.Obj, While = _ref.While, Comment = _ref.Comment, Arr = _ref.Arr, Obj = _ref.Obj, TypeAssign = _ref.TypeAssign, DeclareType = _ref.DeclareType, Cast = _ref.Cast, TypeArr = _ref.TypeArr, TypeObj = _ref.TypeObj, TypeName = _ref.TypeName, PointerType = _ref.PointerType, ArrowType = _ref.ArrowType, StructType = _ref.StructType;

  _ref1 = require('./helpers'), flatten = _ref1.flatten, extend = _ref1.extend, tystr = _ref1.tystr;

  error = function(node, msg) {
    var err;
    err = new TypeError(msg);
    err.lineno = node.lineno;
    throw err;
  };

  HEAP = new Value(new Literal('_HEAP'));

  I8V = new Literal('_I8');

  U8V = new Literal('_U8');

  I16V = new Literal('_I16');

  U16V = new Literal('_U16');

  I32V = new Literal('_I32');

  U32V = new Literal('_U32');

  F32V = new Literal('_F32');

  F64V = new Literal('_F64');

  SP = new Value(new Literal('_SP'));

  SPREAL = new Value(U32V, [new Index(new Value(new Literal(1)))]);

  MALLOC = new Value(new Literal('malloc'));

  FREE = new Value(new Literal('free'));

  MEMCPY = new Value(new Literal('memcpy'));

  recorderForView = function(view) {
    return function(o) {
      var name;
      name = view.value;
      o.scope.assign(name, "" + HEAP.base.value + "." + (name.substr(name.lastIndexOf('_') + 1)));
      return view;
    };
  };

  I8 = recorderForView(I8V);

  U8 = recorderForView(U8V);

  I16 = recorderForView(I16V);

  U16 = recorderForView(U16V);

  I32 = recorderForView(I32V);

  U32 = recorderForView(U32V);

  F32 = recorderForView(F32V);

  F64 = recorderForView(F64V);

  I8.BYTES_PER_ELEMENT = U8.BYTES_PER_ELEMENT = 1;

  I16.BYTES_PER_ELEMENT = U16.BYTES_PER_ELEMENT = 2;

  I32.BYTES_PER_ELEMENT = U32.BYTES_PER_ELEMENT = 4;

  F32.BYTES_PER_ELEMENT = 4;

  F64.BYTES_PER_ELEMENT = 8;

  opts = {
    warn: false,
    unsafe: false
  };

  printWarn = function(line) {
    if (opts.warn) {
      return process.stderr.write('warning: ' + line + '\n');
    }
  };

  normalizePtr = function(ptr, lalign, ralign) {
    var inner, op, ratio;
    if (lalign === ralign || ((inner = ptr.unwrapAll()) instanceof Literal && inner.value === '0' || inner.value === 'null')) {
      return ptr;
    }
    if (lalign < ralign) {
      ratio = ralign / lalign;
      op = '<<';
    } else {
      ratio = lalign / ralign;
      op = '>>';
    }
    return new Parens(new Op(op, ptr, new Value(new Literal(Math.log(ratio) / Math.log(2)))));
  };

  offsetExpr = function(base, baseTy, offset, offsetTy) {
    var balign, normalized, oalign;
    balign = baseTy.view.BYTES_PER_ELEMENT;
    oalign = offsetTy.view.BYTES_PER_ELEMENT;
    normalized = normalizePtr(base, balign, oalign);
    if (offset !== 0) {
      return new Op('+', normalized, new Value(new Literal(offset / oalign)));
    } else {
      return normalized;
    }
  };

  stackOffsetExpr = function(offset, offsetTy) {
    return offsetExpr(SP, SP.computedType, offset, offsetTy);
  };

  multExpr = function(base, size) {
    if (size && ((size & (size - 1)) === 0)) {
      return new Parens(new Op('<<', base, new Value(new Literal(Math.log(size) / Math.log(2)))));
    } else {
      return new Op('*', base, new Value(new Literal(size)));
    }
  };

  freshVariable = function(name) {
    var lit;
    lit = new Literal;
    lit.transformNode = function(o) {
      this.value = o.scope.freeVariable(name);
      delete this.transformNode;
    };
    return lit;
  };

  Binding = (function() {

    function Binding(type) {
      this.type = type;
    }

    return Binding;

  })();

  Scope.prototype.binding = function(name, immediate) {
    var found, _ref2;
    found = this.type(name);
    if (found || immediate) {
      return found;
    }
    return (_ref2 = this.parent) != null ? _ref2.binding(name) : void 0;
  };

  Base.prototype.foldChildren = function(r, pre, post, o) {
    var attr, child, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref2, _ref3, _ref4, _ref5;
    r = typeof this[pre] === 'function' ? this[pre](r, o) : r;
    if (!this.children) {
      return r;
    }
    if (o.immediate) {
      _ref2 = this.children;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        attr = _ref2[_i];
        if (this[attr]) {
          _ref3 = flatten([this[attr]]);
          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
            child = _ref3[_j];
            r = typeof child[pre] === 'function' ? child[pre](r, o) : r;
            r = post && typeof child[post] === 'function' ? child[post](r, o) : r;
          }
        }
      }
    } else {
      _ref4 = this.children;
      for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
        attr = _ref4[_k];
        if (this[attr]) {
          _ref5 = flatten([this[attr]]);
          for (_l = 0, _len3 = _ref5.length; _l < _len3; _l++) {
            child = _ref5[_l];
            r = child.foldChildren(r, pre, post, o);
          }
        }
      }
    }
    if (post && typeof this[post] === 'function') {
      return this[post](r, o);
    } else {
      return r;
    }
  };

  Code.prototype.foldChildren = function(r, pre, post, o) {
    if (!o.crossScope) {
      return r;
    }
    return Code.__super__.foldChildren.call(this, r, pre, post, extend({}, o));
  };

  TypeAssign.prototype.collectType = function(types) {
    types[this.name] = this.type;
    return types;
  };

  alignOffset = function(offset, ty) {
    var size;
    size = ty.view.BYTES_PER_ELEMENT;
    return (((offset - 1) / size + 1) | 0) * size;
  };

  alignmentUnits = function(ty) {
    return ty.size / ty.view.BYTES_PER_ELEMENT;
  };

  TypeName.prototype.lint = function(types) {
    var linted, _ref2;
    if (this.linting) {
      error(this, "circular type synonym: " + this.name);
    }
    if (this.linted) {
      return this.linted;
    }
    this.linting = true;
    if (!(this.name in types)) {
      error(this, "cannot resolve type `" + this.name + "'");
    }
    linted = (_ref2 = types[this.name]) != null ? _ref2.lint(types) : void 0;
    delete this.linting;
    return this.linted = linted;
  };

  PointerType.prototype.size = 4;

  PointerType.prototype.view = U32;

  PointerType.prototype.baseAlignment = function() {
    var _ref2;
    return ((_ref2 = this.base) != null ? _ref2.view.BYTES_PER_ELEMENT : void 0) || 1;
  };

  PointerType.prototype.lint = function(types) {
    var base;
    if (this.linted) {
      return this;
    }
    this.linted = true;
    this.base = base = this.base.lint(types);
    if (base && !base.size) {
      error(this, "cannot take pointers of unsized type `" + base + "'");
    }
    return this;
  };

  PointerType.prototype.coerce = function(expr) {
    var ty;
    ty = expr.unwrapAll().computedType;
    if (!(ty instanceof PointerType && ty !== this)) {
      return expr;
    }
    return normalizePtr(expr, this.baseAlignment(), ty.baseAlignment());
  };

  TypeArr.prototype.lint = function(types) {
    var el, i, _i, _len, _ref2;
    if (this.linted) {
      return this;
    }
    this.linted = true;
    _ref2 = this.elements;
    for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {
      el = _ref2[i];
      this.elements[i] = el.lint(types);
    }
    return this;
  };

  TypeObj.prototype.lint = function(types) {
    var field, _i, _len, _ref2;
    if (this.linted) {
      return this;
    }
    this.linted = true;
    _ref2 = this.fields;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      field = _ref2[_i];
      field.type = field.type.lint(types);
    }
    return this;
  };

  StructType.prototype.lint = function(types) {
    var align, field, field2, fields, maxView, offset, prev, s, size, ty, ty2, _i, _j, _k, _l, _len, _len1, _len2, _len3;
    if (this.linted) {
      return this;
    }
    this.linted = true;
    this.size = 1;
    fields = this.fields;
    for (_i = 0, _len = fields.length; _i < _len; _i++) {
      field = fields[_i];
      field.type = field.type.lint(types);
    }
    prev = {
      offset: 0,
      type: {
        size: 0
      }
    };
    size = 0;
    maxView = U8;
    for (_j = 0, _len1 = fields.length; _j < _len1; _j++) {
      field = fields[_j];
      ty = field.type;
      if (!ty.size) {
        error(this, "cannot store unsized type `" + ty + "' as a struct field");
      }
      if (ty.view.BYTES_PER_ELEMENT > maxView.BYTES_PER_ELEMENT) {
        maxView = ty.view;
      }
      if ((offset = field.offset) != null) {
        if (offset < 0) {
          error(this, "struct field offsets cannot be negative");
        }
        if (offset < prev.offset) {
          printWarn("offset of field `" + field.name + "' is smaller offset of previous field");
        }
        if (offset !== alignOffset(offset, ty)) {
          error(this, "manual offset [" + offset + "] cannot be aligned to `" + ty + "'");
        }
      } else if (field.usePreviousOffset) {
        if ((field.offset = alignOffset(prev.offset, ty)) !== prev.offset) {
          prev.offset = field.offset;
        }
      } else {
        field.offset = alignOffset(prev.offset + prev.type.size, ty);
      }
      if ((s = field.offset + ty.size) > size) {
        size = s;
      }
      prev = field;
    }
    for (_k = 0, _len2 = fields.length; _k < _len2; _k++) {
      field = fields[_k];
      if ((ty = field.type) instanceof PointerType) {
        for (_l = 0, _len3 = fields.length; _l < _len3; _l++) {
          field2 = fields[_l];
          if (field2.offset === field.offset && (ty2 = field2.type) instanceof PointerType) {
            unify(types, ty, ty2, true && unify(types, ty2, ty, true));
          }
        }
      }
    }
    align = maxView.BYTES_PER_ELEMENT;
    this.size = (((size - 1) / align + 1) | 0) * align;
    this.view = maxView;
    return this;
  };

  ArrowType.prototype.lint = function(types) {
    var i, params, ty, _i, _len;
    if (this.linted) {
      return this;
    }
    this.linted = true;
    ty = this.ret.lint(types);
    this.ret = ty;
    params = this.params;
    for (i = _i = 0, _len = params.length; _i < _len; i = ++_i) {
      ty = params[i];
      params[i] = ty.lint(types);
    }
    return this;
  };

  unify = function(types, lty, rty, assign) {
    var i, lpty, lptys, ptys, rptys, _i, _len;
    if (lty === rty) {
      return lty;
    }
    if (!(lty && rty)) {
      return;
    }
    if (lty instanceof PointerType && rty instanceof PointerType) {
      if (assign) {
        if (rty.base && rty.baseAlignment() < lty.baseAlignment()) {
          printWarn("incompatible pointer conversion from `" + rty + "' to `" + lty + "' may alter its value");
        }
        return lty;
      } else {
        if (lty.base === rty.base) {
          return lty;
        }
      }
    }
    if (lty instanceof ArrowType && rty instanceof ArrowType) {
      lptys = lty.params;
      rptys = rty.params;
      if (lptys.length !== rptys.length) {
        return;
      }
      ptys = [];
      for (i = _i = 0, _len = lptys.length; _i < _len; i = ++_i) {
        lpty = lptys[i];
        ptys.push(unify(types, lpty, rptys[i], assign));
      }
      return new ArrowType(ptys, unify(types, lty.ret, rty.ret, assign));
    }
    if (lty instanceof PointerType && __indexOf.call(integral, rty) >= 0) {
      printWarn("conversion from `" + rty + "' to pointer without cast");
      return lty;
    }
    if (__indexOf.call(integral, lty) >= 0 && rty instanceof PointerType) {
      printWarn("conversion from pointer to `" + lty + "' without cast");
      return lty;
    }
    if (__indexOf.call(numeric, lty) >= 0 && __indexOf.call(numeric, rty) >= 0) {
      if (lty.size !== rty.size) {
        printWarn("conversion from `" + rty + "' to `" + lty + "' may alter its value");
        if (assign) {
          return lty;
        } else if (lty.size > rty.size) {
          return lty;
        } else {
          return rty;
        }
      }
      if (lty.signed !== rty.signed) {
        printWarn("conversion from `" + rty + "' to `" + lty + "' may alter its sign");
        return lty;
      }
    }
    return null;
  };

  Op.prototype.isAssignable = Op.prototype.isDeref = function() {
    return !this.second && this.operator === '*';
  };

  Block.prototype.computeType = function(r, o) {
    var exprs;
    exprs = this.expressions;
    if (!(exprs.length > 1)) {
      return;
    }
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    return this.computedType = exprs[exprs.length - 1].unwrapAll().computedType;
  };

  If.prototype.computeType = function(r, o) {
    var elseTy, thenTy, ty, _ref2, _ref3;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    thenTy = (_ref2 = this.body) != null ? _ref2.unwrapAll().computedType : void 0;
    elseTy = (_ref3 = this.elseBody) != null ? _ref3.unwrapAll().computedType : void 0;
    this.computedType = ty = unify(o.types, thenTy, elseTy);
    if ((thenTy || elseTy) && !ty) {
      return printWarn("branches of if have different types: `" + (tystr(thenTy)) + "' and `" + (tystr(elseTy)) + "'");
    }
  };

  Switch.prototype.computeType = function(r, o) {
    var block, caseTys, conds, cty, i, someCaseJumps, someCaseTyped, ty, types, _i, _len, _ref2, _ref3;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    types = o.types;
    caseTys = [];
    someCaseJumps = false;
    someCaseTyped = false;
    _ref2 = this.cases;
    for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {
      _ref3 = _ref2[i], conds = _ref3[0], block = _ref3[1];
      if (block.jumps()) {
        ty = null;
        someCaseJumps = true;
      } else {
        ty = block.unwrapAll().computedType;
      }
      caseTys.push(ty);
      if (ty) {
        someCaseTyped = true;
      }
      if (i === 0) {
        cty = ty;
      } else {
        cty = unify(types, ty, cty);
      }
    }
    if (this.otherwise) {
      cty = unify(types, this.otherwise.unwrapAll().computedType, cty);
    }
    if (someCaseTyped && !cty) {
      if (someCaseJumps) {
        printWarn("cannot type switch with jumps");
      } else {
        printWarn("branches of switch have different types: `" + (((function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = caseTys.length; _j < _len1; _j++) {
            ty = caseTys[_j];
            _results.push(tystr(ty));
          }
          return _results;
        })()).join('\', `')) + "'");
      }
    }
    return this.computedType = cty;
  };

  Cast.prototype.computeType = function(r, o) {
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    return this.computedType = this.type.lint(o.types);
  };

  Assign.prototype.computeType = function(r, o) {
    var context, lty, msg, rty, value;
    if (this.context === 'object') {
      delete this.variable.computedType;
      return;
    }
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    if (!(lty = this.variable.unwrapAll().computedType)) {
      return;
    }
    value = this.value.unwrapAll();
    if (lty instanceof PointerType && value instanceof Literal && value.value === '0') {
      value.computedType = anyPtrTy;
    }
    rty = value.computedType;
    context = this.context;
    this.computedType = context ? binopType(context.substr(0, context.indexOf('=')), lty, rty) : unify(o.types, lty, rty, true);
    if (!this.computedType) {
      msg = "incompatible types: assigning `" + (tystr(rty)) + "' to `" + lty + "'";
      if (context) {
        return error(this.variable, msg + (" using " + context));
      } else {
        return error(this.variable, msg);
      }
    }
  };

  Value.prototype.computeType = function(r, o) {
    var baseTy, field, fieldName, inner, prop, val, _i, _len, _ref2, _ref3;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    inner = this.base.unwrapAll();
    if (inner instanceof Literal) {
      val = inner.value;
      inner.computedType = val === 'null' ? anyPtrTy : inner.isAssignable() ? (_ref2 = (this.computedBinding = o.scope.binding(val))) != null ? _ref2.type : void 0 : inner.isSimpleNumber() ? i32ty : !isNaN(number(val)) ? f64ty : void 0;
    }
    if (baseTy = inner.computedType) {
      _ref3 = this.properties;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        prop = _ref3[_i];
        if (baseTy instanceof PointerType) {
          baseTy = baseTy.base;
        }
        if (!(baseTy instanceof StructType)) {
          return;
        }
        if (prop.soak) {
          error(this, "cannot soak struct field names");
        }
        fieldName = prop.name.unwrapAll().value;
        field = prop.computedField = baseTy.names[fieldName];
        if (!field) {
          error(this, "unknown struct field name `" + fieldName + "'");
        }
        baseTy = field.type;
      }
      return this.computedType = baseTy;
    }
  };

  Code.prototype.computeType = function(r, o) {
    var i, rexpr, rty, types, _i, _len, _ref2;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    this.spOffsets = spOffsets(o.scope);
    this.frameSize = o.scope.frameSize;
    types = o.types;
    _ref2 = returnExpressions(this.body);
    for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {
      rexpr = _ref2[i];
      if (i === 0) {
        rty = rexpr.unwrapAll().computedType;
      } else {
        rty = unify(types, rexpr.unwrapAll().computedType, rty);
      }
    }
    return this.computedType = new ArrowType(this.paramTypes, rty);
  };

  Call.prototype.computeType = function(r, o) {
    var args, aty, fty, i, paramTys, pty, types, _i, _len, _ref2, _ref3, _ref4;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    if (!(fty = (_ref2 = this.variable) != null ? _ref2.unwrapAll().computedType : void 0)) {
      return;
    }
    if (!(fty instanceof ArrowType)) {
      error(this, "calling a non-function type `" + fty + "'");
    }
    paramTys = fty.params;
    args = this.args;
    types = o.types;
    _ref3 = fty.params;
    for (i = _i = 0, _len = _ref3.length; _i < _len; i = ++_i) {
      pty = _ref3[i];
      aty = (_ref4 = args[i]) != null ? _ref4.computedType : void 0;
      if (pty && !unify(types, pty, aty, true)) {
        error(this, "incompatible types: passing arg `" + (tystr(aty)) + "' to param `" + (tystr(pty)) + "'");
      }
    }
    return this.computedType = fty.ret;
  };

  ARITH = ['+', '-', '*', '/'];

  BITWISE = ['<<', '>>', '>>>', '~', '&', '|'];

  COMPARE = ['===', '!==', '<', '>', '<=', '>='];

  binopType = function(op, ty1, ty2) {
    if ((op === '+' || op === '-') && ty1 instanceof PointerType) {
      if (__indexOf.call(integral, ty2) >= 0) {
        return ty1;
      } else if (op === '-' && ty2 instanceof PointerType) {
        if (!unify(o.types, ty1.base, ty2.base)) {
          printWarn("pointer subtraction on incompatible pointer types `" + ty1 + "' and `" + ty2 + "'");
        }
        return i32ty;
      } else {
        return error(this, "invalid operand type `" + ty2 + "' for pointer arithmetic");
      }
    } else if (op === '%') {
      return i32ty;
    } else if (__indexOf.call(COMPARE, op) >= 0) {
      if (ty1 instanceof PointerType && ty2 instanceof PointerType && !unify(o.types, ty1, ty2)) {
        printWarn("comparison between incompatible pointer types `" + ty1 + "' and `" + ty2 + "'");
      }
      return i32ty;
    } else if (__indexOf.call(BITWISE, op) >= 0) {
      return i32ty;
    } else if (__indexOf.call(ARITH, op) >= 0 && __indexOf.call(numeric, ty1) >= 0 && __indexOf.call(numeric, ty2) >= 0) {
      return f64ty;
    }
  };

  Op.prototype.computeType = function(r, o) {
    var first, name, op, scope, tmp, ty1, ty2;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    op = this.operator;
    if (this.isUnary()) {
      first = this.first.unwrapAll();
      return this.computedType = op === 'new' && first.value in o.types ? (ty1 = o.types[first.value], !(ty1 != null ? ty1.size : void 0) ? error(this, "cannot allocate unsized type `" + ty1 + "'") : void 0, Scope.root.needsMalloc = true, new PointerType(ty1)) : op === 'delete' && (ty1 = first.computedType) ? (!(ty1 instanceof PointerType) ? error(this, 'cannot free non-pointer type') : void 0, Scope.root.needsMalloc = true, null) : op === 'sizeof' ? (ty1 = this.first = this.first.lint(o.types), !ty1.size ? error(this, "cannot determine size of type `" + ty1 + "'") : void 0, i32ty) : op === '&' ? (ty1 = first.computedType, !ty1 ? error(this, "taking reference of an untyped expression `" + (this.first.compile(o)) + "'") : void 0, ty1 instanceof ArrowType ? error(this, "taking reference of a function type") : void 0, !first.isAssignable() ? error(this, "taking reference of non-assignable") : void 0, first instanceof Literal ? (name = first.value, scope = o.scope, !scope.check(name, true) ? error(this, "taking reference of non-local or undefined variable `" + name + "'") : void 0, putOnStack(scope, name)) : void 0, new PointerType(ty1)) : op === '*' && (ty1 = first.computedType) ? (!ty1 ? error(this, "dereferencing an untyped expression:\n" + this.first) : void 0, !(ty1 instanceof PointerType) ? error(this, "dereferencing a non-pointer type") : void 0, ty1.base) : (op === '++' || op === '--') && (ty1 = first.computedType) ? ty1 instanceof PointerType || __indexOf.call(integral, ty1) >= 0 ? ty1 : void 0 : void 0;
    }
    ty1 = this.first.unwrapAll().computedType;
    ty2 = this.second.unwrapAll().computedType;
    if (ty2 instanceof PointerType) {
      tmp = ty1;
      ty1 = ty2;
      ty2 = tmp;
    }
    return this.computedType = (op === '+' || op === '-') && ty1 instanceof PointerType ? (__indexOf.call(integral, ty2) < 0 ? error(this, "invalid operand type `" + ty2 + "' for pointer arithmetic") : void 0, ty1) : op === '-' && ty1 instanceof PointerType && ty2 instanceof PointerType ? (!unify(o.types, ty1.base, ty2.base) ? printWarn("pointer subtraction on incompatible pointer types `" + ty1 + "' and `" + ty2 + "'") : void 0, i32ty) : op === '%' ? i32ty : __indexOf.call(COMPARE, op) >= 0 ? (ty1 instanceof PointerType && ty2 instanceof PointerType && !unify(o.types, ty1, ty2) ? printWarn("comparison between incompatible pointer types `" + ty1 + "' and `" + ty2 + "'") : void 0, i32ty) : __indexOf.call(BITWISE, op) >= 0 ? i32ty : __indexOf.call(ARITH, op) >= 0 && __indexOf.call(numeric, ty1) >= 0 && __indexOf.call(numeric, ty2) >= 0 ? f64ty : void 0;
  };

  returnExpressions = function(body) {
    var exprs;
    exprs = body.expressions;
    return body.foldChildren([exprs[exprs.length - 1]], 'returnExpression', null, {});
  };

  undefExpr = new Value(new Literal('undefined'));

  Return.prototype.returnExpression = function(exprs, o) {
    exprs.push(this.expression || undefExpr);
    return exprs;
  };

  newTypedScope = function(p, e, m) {
    var scope;
    scope = new Scope(p, e, m);
    scope.variables.length = 0;
    scope.frameSize = 0;
    return scope;
  };

  Assign.prototype.primeComputeType = function(r, o) {
    var fn, name, ty, _ref2;
    if ((fn = this.value.unwrapAll()) instanceof Code && (name = this.variable.unwrapAll()) instanceof Literal && name.isAssignable() && (ty = (_ref2 = o.scope.binding(name.value)) != null ? _ref2.type : void 0) instanceof ArrowType) {
      if (fn.paramTypes == null) {
        fn.paramTypes = ty.params;
      }
      if (fn.returnType == null) {
        fn.returnType = ty.ret;
      }
    }
  };

  Code.prototype.primeComputeType = function(r, o) {
    var i, param, ptys, rexpr, rty, types, _i, _j, _len, _len1, _ref2, _ref3;
    rty = this.returnType;
    if (rty instanceof ArrowType) {
      _ref2 = returnExpressions(this.body);
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        rexpr = _ref2[_i];
        if (!(rexpr instanceof Code)) {
          continue;
        }
        rexpr = rexpr.unwrapAll();
        if (rexpr.paramTypes == null) {
          rexpr.paramTypes = rty.params;
        }
        if (rexpr.returnType == null) {
          rexpr.returnType = rty.ret;
        }
      }
    }
    o.scope = newTypedScope(o.scope, this.body, this);
    ptys = this.paramTypes;
    if (ptys) {
      if (ptys.length !== this.params.length) {
        error(this, "arrow type has different number of parameters than function");
      }
      types = o.types;
      _ref3 = this.params;
      for (i = _j = 0, _len1 = _ref3.length; _j < _len1; i = ++_j) {
        param = _ref3[i];
        param.type = ptys[i];
        param.declareType(r, o);
      }
    }
    this.body.foldChildren(null, 'declareType', null, {
      types: o.types,
      scope: o.scope
    });
  };

  declare = function(scope, v, ty, node) {
    var bind, el, els, i, name, obj, objs, _i, _j, _len, _len1;
    if (v instanceof Literal) {
      if (ty instanceof TypeArr || ty instanceof TypeObj) {
        error(node, "cannot type non-destructuring variable with destructuring type `" + ty + "'");
      }
      name = v.value;
      if (scope.check(name)) {
        error(node, "cannot redeclare typed variable `" + name + "'");
      }
      bind = new Binding(ty);
      scope.add(name, bind);
      node.variables.push({
        name: name,
        type: ty,
        binding: bind
      });
      if (ty instanceof StructType) {
        putOnStack(scope, name);
      }
    }
    if (v instanceof Value) {
      if (v.hasProperties()) {
        error(node, "cannot type properties");
      }
      v = v.base;
    }
    if (v instanceof Arr) {
      els = v.objects;
      if (!(ty instanceof TypeArr)) {
        error(node, "cannot type destructuring array with non-destructuring array type `" + ty + "'");
      }
      for (i = _i = 0, _len = els.length; _i < _len; i = ++_i) {
        el = els[i];
        if (el["this"]) {
          error(node, "cannot type @-names");
        } else {
          declare(scope, el.base, ty.elements[i], node);
        }
      }
      return;
    }
    if (v instanceof Obj) {
      objs = v.objects;
      if (!(ty instanceof TypeObj)) {
        error(node, "cannot type destructuring object with non-destructuring object type `" + ty + "'");
      }
      for (_j = 0, _len1 = objs.length; _j < _len1; _j++) {
        obj = objs[_j];
        if (obj instanceof Assign) {
          name = obj.variable.base;
          declare(scope, obj.value, ty.names[name.value].type, node);
        } else if (obj["this"]) {
          error(node, "cannot type @-names");
        } else {
          name = obj.base;
          declare(scope, name, ty.names[name.value].type, node);
        }
      }
    }
  };

  DeclareType.prototype.declareType = function(r, o) {
    var scope, type, v, _i, _len, _ref2;
    type = this.type.lint(o.types);
    scope = o.scope;
    this.variables = [];
    _ref2 = this.typeables;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      v = _ref2[_i];
      declare(scope, v, type, this);
    }
  };

  Param.prototype.declareType = function(r, o) {
    var scope, type;
    type = this.type.lint(o.types);
    scope = o.scope;
    this.variables = [];
    declare(scope, this.name, type, this);
  };

  putOnStack = function(scope, name) {
    var bind;
    bind = scope.binding(name, true);
    bind.onStack = true;
    bind.spOffset = alignOffset(scope.frameSize, bind.type);
    scope.frameSize = bind.spOffset + bind.type.size;
  };

  spOffsets = function(scope) {
    var bind, name, offsets, _i, _len, _ref2, _ref3;
    offsets = [];
    _ref2 = scope.variables;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      _ref3 = _ref2[_i], name = _ref3.name, bind = _ref3.type;
      if (bind.onStack) {
        offsets.push({
          name: name,
          offset: bind.spOffset,
          ty: bind.type
        });
      }
    }
    return offsets;
  };

  makeDeref = function(o, base, baseTy, offset, offsetTy) {
    return new Value(offsetTy.view(o), [new Index(offsetExpr(base, baseTy, offset, offsetTy))]);
  };

  inlineMemcpy = function(o, dest, src, ty) {
    var access, assign, destProp, destPtr, field, fty, i, offset, scope, srcProp, srcPtr, stmts, _i, _j, _len, _ref2, _ref3;
    scope = o.scope;
    stmts = [];
    destPtr = freshVariable('dest');
    destPtr.computedType = dest.computedType;
    stmts.push(new Assign(new Value(destPtr), dest));
    srcPtr = freshVariable('src');
    srcPtr.computedType = src.computedType;
    stmts.push(new Assign(new Value(srcPtr), src));
    if (ty instanceof StructType) {
      _ref2 = ty.fields;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        field = _ref2[_i];
        access = new Access(new Literal(field.name));
        access.computedField = field;
        fty = field.type;
        destProp = new Value(destPtr, [access]);
        destProp.computedType = fty;
        srcProp = new Value(srcPtr, [access]);
        srcProp.computedType = fty;
        assign = new Assign(destProp, srcProp);
        assign.computedType = fty;
        stmts.push(assign);
      }
    } else {
      for (i = _j = 0, _ref3 = ty.size; 0 <= _ref3 ? _j < _ref3 : _j > _ref3; i = 0 <= _ref3 ? ++_j : --_j) {
        offset = new Value(new Literal(i));
        stmts.push(new Assign(new Value(U8(o), [new Index(new Op('+', new Value(destPtr), offset))]), new Value(U8(o), [new Index(new Op('+', new Value(srcPtr), offset))])));
      }
    }
    stmts.push(new Value(destPtr));
    return new Value(new Parens(new Block(stmts)));
  };

  structLiteral = function(v, ty, o) {
    var access, field, fname, obj, propList, propValue, ptr, _i, _len, _ref2;
    ptr = freshVariable('ptr');
    propList = [];
    _ref2 = ty.fields;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      field = _ref2[_i];
      fname = field.name;
      access = new Access(new Literal(fname));
      access.computedField = field;
      propValue = new Value(ptr, [access]);
      propValue.computedType = field.type;
      propList.push(new Assign(new Value(new Literal(fname)), propValue.transformNode(), 'object'));
    }
    obj = new Value(new Obj(propList));
    return new Value(new Parens(new Block([new Assign(new Value(ptr), v), obj])));
  };

  stackFence = function(o, exprs, frameSize, spOffsets, isRoot) {
    var name, offset, restoreStack, scope, ty, _i, _len, _ref2;
    U32(o);
    scope = o.scope;
    for (_i = 0, _len = spOffsets.length; _i < _len; _i++) {
      _ref2 = spOffsets[_i], name = _ref2.name, offset = _ref2.offset, ty = _ref2.ty;
      exprs.unshift(new Assign(new Value(new Literal(name)), stackOffsetExpr(offset, ty)));
    }
    exprs.unshift(new Assign(SP, normalizePtr(SPREAL, U32.BYTES_PER_ELEMENT, 1)));
    exprs.unshift(new Assign(SPREAL, new Value(new Literal(frameSize)), '-='));
    restoreStack = new Assign(SPREAL, new Value(new Literal(frameSize)), '+=');
    if (opts.unsafe) {
      if (isRoot) {
        exprs.push(restoreStack);
      }
    } else {
      exprs[0] = new Try(new Block(exprs.slice()), null, null, new Block([restoreStack]));
      exprs.length = 1;
    }
  };

  Cast.prototype.transformNode = function(o) {
    var _base;
    return typeof (_base = this.computedType).coerce === "function" ? _base.coerce(this.expr) : void 0;
  };

  Code.prototype.transformNode = function(o) {
    var arg, assign, exprs, frameSize, name, param, plh, prh, save, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
    o.returnType = (_ref2 = this.computedType) != null ? _ref2.ret : void 0;
    if (frameSize = this.frameSize) {
      exprs = this.body.expressions;
      _ref3 = this.params;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        param = _ref3[_i];
        _ref4 = param.variables;
        for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
          arg = _ref4[_j];
          if (arg.binding.onStack) {
            arg.save = freshVariable(arg.name);
            plh = new Value(new Literal(arg.name));
            prh = new Value(arg.save);
            assign = new Assign(plh, prh);
            assign.computedType = plh.computedType = prh.computedType = arg.type;
            plh.computedBinding = arg.binding;
            exprs.unshift(assign);
          }
        }
      }
      o.frameSize = frameSize;
      stackFence(o, exprs, frameSize, this.spOffsets);
      _ref5 = this.params;
      for (_k = 0, _len2 = _ref5.length; _k < _len2; _k++) {
        param = _ref5[_k];
        _ref6 = param.variables;
        for (_l = 0, _len3 = _ref6.length; _l < _len3; _l++) {
          _ref7 = _ref6[_l], name = _ref7.name, save = _ref7.save;
          exprs.unshift(new Assign(new Value(save), new Value(new Literal(name))));
        }
      }
    }
  };

  Return.prototype.transformNode = function(o) {
    var body, expr, frameSize, restoreStack, ty;
    if (ty = o.returnType) {
      this.expression = typeof ty.coerce === "function" ? ty.coerce(this.expression) : void 0;
    }
    if (!((frameSize = o.frameSize) && opts.unsafe)) {
      return;
    }
    restoreStack = new Assign(SPREAL, new Value(new Literal(frameSize)), '+=');
    if (expr = this.expression) {
      body = new Block;
      body.transformNode = function(o) {
        var tmp;
        tmp = new Value(freshVariable('t'));
        this.expressions = [new Assign(tmp, expr), restoreStack, tmp];
      };
    } else {
      body = new Block([restoreStack, new Return]);
    }
    this.expression = new Value(new Parens(body));
  };

  Call.prototype.transformNode = function(o) {
    var args, fty, i, paramTys, pty, _i, _len, _ref2, _ref3;
    if (!(fty = (_ref2 = this.variable) != null ? _ref2.unwrapAll().computedType : void 0)) {
      return;
    }
    paramTys = fty.params;
    args = this.args;
    _ref3 = fty.params;
    for (i = _i = 0, _len = _ref3.length; _i < _len; i = ++_i) {
      pty = _ref3[i];
      args[i] = typeof pty.coerce === "function" ? pty.coerce(args[i]) : void 0;
    }
  };

  Value.prototype.transformNode = function(o) {
    var base, cumulativeOffset, field, fty, inner, prop, props, ty, v, vty, _i, _len, _ref2;
    if (!(ty = this.computedType)) {
      return;
    }
    base = this.base;
    inner = base.unwrapAll();
    props = this.properties;
    if (!props.length) {
      if (inner instanceof Literal) {
        if (((_ref2 = this.computedBinding) != null ? _ref2.onStack : void 0) && !(ty instanceof StructType) && !inner.noStackDeref) {
          return new Value(U32(o), [new Index(new Value(new Literal(inner.value)))]);
        }
        if (inner.value === 'null' && ty instanceof PointerType) {
          inner.value = '0';
        }
      }
      return;
    }
    v = (typeof inner.isDeref === "function" ? inner.isDeref() : void 0) ? inner.first : base;
    vty = v.unwrapAll().computedType;
    cumulativeOffset = 0;
    for (_i = 0, _len = props.length; _i < _len; _i++) {
      prop = props[_i];
      field = prop.computedField;
      if ((fty = field.type) instanceof StructType) {
        cumulativeOffset += field.offset;
      } else {
        v = makeDeref(o, v, vty, field.offset + cumulativeOffset, fty);
        vty = fty;
        cumulativeOffset = 0;
      }
    }
    if (fty instanceof StructType && cumulativeOffset !== 0) {
      return new Op('+', v, new Value(new Literal(cumulativeOffset)));
    } else {
      return v;
    }
  };

  Assign.prototype.transformNode = function(o) {
    var au, lty, lval;
    if (!(lty = this.computedType)) {
      return;
    }
    if (lty instanceof StructType) {
      lval = this.variable.unwrapAll();
      return inlineMemcpy(o, ((typeof lval.isDeref === "function" ? lval.isDeref() : void 0) ? lval.first : this.variable), this.value, lty);
    }
    if (lty instanceof PointerType && this.context && (au = alignmentUnits(lty.base)) !== 1) {
      this.value = new Op('*', this.value, new Value(new Literal(au)));
    } else if (lty.coerce) {
      this.value = lty.coerce(this.value);
    }
  };

  Op.prototype.transformNode = function(o) {
    var au, op, op1, op2, size, ty1, ty2;
    if (!(this.computedType || this.first.computedType)) {
      return;
    }
    op = this.operator;
    if (this.isUnary()) {
      if (op === 'new' && (ty1 = this.computedType)) {
        return new Call(MALLOC, [new Value(new Literal(ty1.base.size))]);
      } else if (op === 'delete') {
        return new Call(FREE, [this.first]);
      } else if (op === 'sizeof') {
        return new Literal(this.first.size);
      } else if (op === '&' && (ty1 = this.computedType.base)) {
        this.first.unwrapAll().noStackDeref = true;
        return this.first;
      } else if (op === '*') {
        ty1 = this.first.computedType;
        return makeDeref(o, this.first, ty1, 0, ty1);
      } else if ((op === '++' || op === '--') && (ty1 = this.computedType) instanceof PointerType && (au = alignmentUnits(ty1.base)) !== 1) {
        size = new Value(new Literal(au));
        if (op === '++') {
          op1 = '+=';
          op2 = '-';
        } else {
          op1 = '-=';
          op2 = '-';
        }
        return new Value(new Parens(new Block([new Assign(this.first, size, op1), new Op(op2, this.first, size)])));
      }
    } else {
      ty1 = this.first.computedType;
      ty2 = this.second.computedType;
      if ((op === '+' || op === '-') && ((ty1 instanceof PointerType && __indexOf.call(integral, ty2) >= 0 && (au = alignmentUnits(ty1.base)) !== 1) || (ty2 instanceof PointerType && __indexOf.call(integral, ty1) >= 0 && (au = alignmentUnits(ty2.base)) !== 1))) {
        size = new Value(new Literal(au));
        if (ty1 instanceof PointerType) {
          this.second = new Op('*', this.second, size);
        } else {
          this.first = new Op('*', this.first, size);
        }
      } else if (__indexOf.call(COMPARE, op) >= 0 && ty1 instanceof PointerType && ty2 instanceof PointerType) {
        this.second = ty1.coerce(this.second);
      }
    }
  };

  coerceIntegral = function(width, signed) {
    return function(expr) {
      var c, shiftBy, ty;
      ty = expr.unwrapAll().computedType;
      if (ty === this) {
        return expr;
      }
      if (width !== 32 && ty.size << 3 > width) {
        c = new Op('&', expr, new Value(new Literal('0x' + ((1 << width) - 1).toString(16))));
        if (signed) {
          shiftBy = new Value(new Literal(32 - width));
          c = new Op('>>', new Op('<<', c, shiftBy), shiftBy);
        }
        return c;
      } else if (ty.signed !== signed) {
        return new Op((signed ? '|' : '>>>'), expr, new Value(new Literal('0')));
      } else {
        return expr;
      }
    };
  };

  PrimitiveType = (function() {

    function PrimitiveType(size, debugName, view, signed, coerce) {
      this.size = size;
      this.debugName = debugName;
      this.view = view;
      this.signed = signed;
      this.coerce = coerce;
    }

    PrimitiveType.prototype.lint = function(types) {
      return this;
    };

    PrimitiveType.prototype.toString = function() {
      return this.debugName;
    };

    return PrimitiveType;

  })();

  anyPtrTy = new PointerType(null);

  i8ty = new PrimitiveType(1, 'i8', I8, true, coerceIntegral(8, true));

  u8ty = new PrimitiveType(1, 'u8', U8, false, coerceIntegral(8, false));

  i16ty = new PrimitiveType(2, 'i16', I16, true, coerceIntegral(16, true));

  u16ty = new PrimitiveType(2, 'u16', U16, false, coerceIntegral(16, false));

  i32ty = new PrimitiveType(4, 'i32', I32, true, coerceIntegral(32, true));

  u32ty = new PrimitiveType(4, 'u32', U32, false, coerceIntegral(32, false));

  f64ty = new PrimitiveType(8, 'double', F64, true);

  integral = [i8ty, u8ty, i16ty, u16ty, i32ty, u32ty];

  numeric = integral.concat([f64ty]);

  SP.computedType = u32ty;

  SPREAL.computedType = u8ty;

  SPREAL.transformNode = null;

  requireExpr = function(name) {
    return new Call(new Value(new Literal('require')), [new Value(new Literal("'" + name + "'"))]);
  };

  exports.analyzeTypes = function(root, o) {
    var initialTypes, name, options, scope, ty, types, usesTypes;
    usesTypes = false;
    root.traverseChildren(true, function(node) {
      if ((node instanceof DeclareType) || (node instanceof Op && node.isUnary() && (node.operator === '&' || node.operator === '*')) || (node instanceof Code && node.paramTypes)) {
        usesTypes = true;
        return false;
      }
    });
    if (!usesTypes) {
      return;
    }
    opts.warn = o.warn;
    opts.unsafe = o.unsafe;
    initialTypes = {
      any: null,
      i8: i8ty,
      u8: u8ty,
      i16: i16ty,
      u16: u16ty,
      i32: i32ty,
      u32: u32ty,
      byte: u8ty,
      short: i16ty,
      int: i32ty,
      uint: u32ty,
      double: f64ty,
      num: f64ty
    };
    types = root.foldChildren(initialTypes, 'collectType', null, {
      immediate: true
    });
    for (name in types) {
      ty = types[name];
      if (ty) {
        types[name] = ty.lint(types);
      }
    }
    scope = newTypedScope(null, root, null);
    options = {
      types: types,
      scope: scope
    };
    root.foldChildren(null, 'declareType', null, options);
    options.crossScope = true;
    root.foldChildren(null, 'primeComputeType', 'computeType', options);
    root.spOffsets = spOffsets(scope);
    root.frameSize = scope.frameSize;
    root.transformRoot = function(o) {
      var exprs, frameSize, obj;
      o.scope.assign(HEAP.base.value, "require('heap/heap')");
      exprs = this.expressions;
      if (frameSize = this.frameSize) {
        o.frameSize = frameSize;
        stackFence(o, exprs, frameSize, this.spOffsets, true);
      }
      if (scope.needsMalloc) {
        obj = new Value(new Obj([MALLOC, FREE]));
        return exprs.unshift(new Assign(obj, requireExpr('heap/malloc')));
      }
    };
    return types;
  };

}).call(this);
