// Generated by CoffeeScript 1.3.1
(function() {
  var ARITH, Access, ArrowType, Assign, BITWISE, Base, Binding, Block, COMPARE, Call, Cast, Code, Comment, DeclareType, FREE, I16, I32, I8, Index, Literal, MALLOC, MEMCPY, Obj, Op, Parens, PointerType, PrimitiveType, Return, SP, SPREAL, Scope, StructType, Try, TypeAssign, TypeName, U16, U32, U8, Value, While, alignOffset, alignmentUnits, anyPtrTy, byteTy, extend, flatten, inlineMemcpy, intTy, makeDeref, multExpr, newTypedScope, normalizePtr, offsetExpr, opts, primTys, printWarn, putOnStack, requireExpr, returnExpressions, shortTy, spOffsetMap, stackFence, stackOffsetExpr, stackOffsetTransform, structLiteral, tystr, uintTy, undefExpr, unify, _ref, _ref1,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Scope = require('./scope').Scope;

  _ref = require('./nodes'), Base = _ref.Base, Parens = _ref.Parens, Block = _ref.Block, Value = _ref.Value, Literal = _ref.Literal, Op = _ref.Op, Assign = _ref.Assign, Try = _ref.Try, Code = _ref.Code, Index = _ref.Index, Access = _ref.Access, Call = _ref.Call, Return = _ref.Return, Obj = _ref.Obj, While = _ref.While, Comment = _ref.Comment, TypeAssign = _ref.TypeAssign, DeclareType = _ref.DeclareType, Cast = _ref.Cast, TypeName = _ref.TypeName, PointerType = _ref.PointerType, ArrowType = _ref.ArrowType, StructType = _ref.StructType;

  _ref1 = require('./helpers'), flatten = _ref1.flatten, extend = _ref1.extend, tystr = _ref1.tystr;

  I8 = new Literal('_I8');

  U8 = new Literal('_U8');

  I16 = new Literal('_I16');

  U16 = new Literal('_U16');

  I32 = new Literal('_I32');

  U32 = new Literal('_U32');

  SP = new Value(new Literal('_SP'));

  SPREAL = new Value(U32, [new Index(new Value(new Literal(1)))]);

  MALLOC = new Value(new Literal('malloc'));

  FREE = new Value(new Literal('free'));

  MEMCPY = new Value(new Literal('memcpy'));

  I8.BYTES_PER_ELEMENT = U8.BYTES_PER_ELEMENT = 1;

  I16.BYTES_PER_ELEMENT = U16.BYTES_PER_ELEMENT = 2;

  I32.BYTES_PER_ELEMENT = U32.BYTES_PER_ELEMENT = 4;

  opts = {
    warn: false,
    unsafe: false
  };

  printWarn = function(line) {
    if (opts.warn) {
      return process.stderr.write('warning: ' + line + '\n');
    }
  };

  normalizePtr = function(ptr, lalign, ralign) {
    var inner, op, ratio;
    if (lalign === ralign || ((inner = ptr.unwrapAll()) instanceof Literal && inner.value === '0' || inner.value === 'null')) {
      return ptr;
    }
    if (lalign < ralign) {
      ratio = ralign / lalign;
      op = '<<';
    } else {
      ratio = lalign / ralign;
      op = '>>';
    }
    return new Parens(new Op(op, ptr, new Value(new Literal(Math.log(ratio) / Math.log(2)))));
  };

  offsetExpr = function(base, baseTy, offset, offsetTy) {
    var balign, normalized, oalign;
    balign = baseTy.view.BYTES_PER_ELEMENT;
    oalign = offsetTy.view.BYTES_PER_ELEMENT;
    normalized = normalizePtr(base, balign, oalign);
    if (offset !== 0) {
      return new Op('+', normalized, new Value(new Literal(offset / oalign)));
    } else {
      return normalized;
    }
  };

  stackOffsetExpr = function(offset, offsetTy) {
    return offsetExpr(SP, SP.computedType, offset, offsetTy);
  };

  multExpr = function(base, size) {
    if (size && ((size & (size - 1)) === 0)) {
      return new Parens(new Op('<<', base, new Value(new Literal(Math.log(size) / Math.log(2)))));
    } else {
      return new Op('*', base, new Value(new Literal(size)));
    }
  };

  Binding = (function() {

    function Binding(type) {
      this.type = type;
    }

    return Binding;

  })();

  Scope.prototype.binding = function(name, immediate) {
    var found, _ref2;
    found = this.type(name);
    if (found || immediate) {
      return found;
    }
    return (_ref2 = this.parent) != null ? _ref2.binding(name) : void 0;
  };

  Base.prototype.foldChildren = function(r, pre, post, o) {
    var attr, child, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref2, _ref3, _ref4, _ref5;
    r = typeof this[pre] === 'function' ? this[pre](r, o) : r;
    if (!this.children) {
      return r;
    }
    if (o.immediate) {
      _ref2 = this.children;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        attr = _ref2[_i];
        if (this[attr]) {
          _ref3 = flatten([this[attr]]);
          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
            child = _ref3[_j];
            r = typeof child[pre] === 'function' ? child[pre](r, o) : r;
            r = post && typeof child[post] === 'function' ? child[post](r, o) : r;
          }
        }
      }
    } else {
      _ref4 = this.children;
      for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
        attr = _ref4[_k];
        if (this[attr]) {
          _ref5 = flatten([this[attr]]);
          for (_l = 0, _len3 = _ref5.length; _l < _len3; _l++) {
            child = _ref5[_l];
            r = child.foldChildren(r, pre, post, o);
          }
        }
      }
    }
    if (post && typeof this[post] === 'function') {
      return this[post](r, o);
    } else {
      return r;
    }
  };

  Code.prototype.foldChildren = function(r, pre, post, o) {
    if (!o.crossScope) {
      return r;
    }
    return Code.__super__.foldChildren.call(this, r, pre, post, extend({}, o));
  };

  TypeAssign.prototype.collectType = function(types) {
    types[this.name] = this.type;
    return types;
  };

  alignOffset = function(offset, ty) {
    var size;
    size = ty.view.BYTES_PER_ELEMENT;
    return (((offset - 1) / size + 1) | 0) * size;
  };

  alignmentUnits = function(ty) {
    return ty.size / ty.view.BYTES_PER_ELEMENT;
  };

  TypeName.prototype.lint = function(types) {
    var linted, _ref2;
    if (this.linting) {
      throw TypeError("circular type synonym: " + this.name);
    }
    if (this.linted) {
      return this.linted;
    }
    this.linting = true;
    if (!(this.name in types)) {
      throw TypeError("cannot resolve type `" + this.name + "'");
    }
    linted = (_ref2 = types[this.name]) != null ? _ref2.lint(types) : void 0;
    delete this.linting;
    return this.linted = linted;
  };

  PointerType.prototype.size = 4;

  PointerType.prototype.view = U32;

  PointerType.prototype.lint = function(types) {
    if (this.linted) {
      return this;
    }
    this.linted = true;
    this.base = this.base.lint(types);
    if (this.base instanceof ArrowType) {
      throw TypeError("cannot take pointers of function types");
    }
    return this;
  };

  PointerType.prototype.baseAlignment = function() {
    var _ref2;
    return ((_ref2 = this.base) != null ? _ref2.view.BYTES_PER_ELEMENT : void 0) || 1;
  };

  StructType.prototype.lint = function(types) {
    var align, field, field2, fields, maxView, offset, prev, s, size, ty, ty2, _i, _j, _k, _l, _len, _len1, _len2, _len3;
    if (this.linted) {
      return this;
    }
    this.linted = true;
    fields = this.fields;
    for (_i = 0, _len = fields.length; _i < _len; _i++) {
      field = fields[_i];
      field.type = field.type.lint(types);
    }
    prev = {
      offset: 0,
      type: {
        size: 0
      }
    };
    size = 0;
    maxView = U8;
    for (_j = 0, _len1 = fields.length; _j < _len1; _j++) {
      field = fields[_j];
      ty = field.type;
      if (ty.view.BYTES_PER_ELEMENT > maxView.BYTES_PER_ELEMENT) {
        maxView = ty.view;
      }
      if ((offset = field.offset) != null) {
        if (offset < 0) {
          throw TypeError("struct field offsets cannot be negative");
        }
        if (offset < prev.offset) {
          printWarn("offset of field `" + field.name + "' is smaller offset of previous field");
        }
        if (offset !== alignOffset(offset, ty)) {
          throw TypeError("manual offset [" + offset + "] cannot be aligned to `" + ty + "'");
        }
      } else if (field.usePreviousOffset) {
        if ((field.offset = alignOffset(prev.offset, ty)) !== prev.offset) {
          prev.offset = field.offset;
        }
      } else {
        field.offset = alignOffset(prev.offset + prev.type.size, ty);
      }
      if ((s = field.offset + ty.size) > size) {
        size = s;
      }
      prev = field;
    }
    for (_k = 0, _len2 = fields.length; _k < _len2; _k++) {
      field = fields[_k];
      if ((ty = field.type) instanceof PointerType) {
        for (_l = 0, _len3 = fields.length; _l < _len3; _l++) {
          field2 = fields[_l];
          if (field2.offset === field.offset && (ty2 = field2.type) instanceof PointerType) {
            unify(types, ty, ty2, true && unify(types, ty2, ty, true));
          }
        }
      }
    }
    align = maxView.BYTES_PER_ELEMENT;
    this.size = (((size - 1) / align + 1) | 0) * align;
    this.view = maxView;
    return this;
  };

  ArrowType.prototype.lint = function(types) {
    var i, params, ty, _i, _len;
    if (this.linted) {
      return this;
    }
    this.linted = true;
    ty = this.ret.lint(types);
    this.ret = ty;
    params = this.params;
    for (i = _i = 0, _len = params.length; _i < _len; i = ++_i) {
      ty = params[i];
      params[i] = ty.lint(types);
    }
    return this;
  };

  unify = function(types, lty, rty, assign) {
    var i, lpty, lptys, ptys, rptys, _i, _len;
    if (lty === rty) {
      return lty;
    }
    if (!(lty && rty)) {
      return;
    }
    if (lty instanceof PointerType && rty instanceof PointerType) {
      if (assign) {
        if (rty.base && rty.baseAlignment() < lty.baseAlignment()) {
          printWarn("incompatible pointer conversion from `" + rty + "' to `" + lty + "' may alter its value");
        }
        return lty;
      } else {
        if (lty.base === rty.base) {
          return lty;
        }
      }
    }
    if (lty instanceof ArrowType && rty instanceof ArrowType) {
      lptys = lty.params;
      rptys = rty.params;
      if (lptys.length !== rptys.length) {
        return;
      }
      ptys = [];
      for (i = _i = 0, _len = lptys.length; _i < _len; i = ++_i) {
        lpty = lptys[i];
        ptys.push(unify(types, lpty, rptys[i], assign));
      }
      return new ArrowType(ptys, unify(types, lty.ret, rty.ret, assign));
    }
    if (lty instanceof PointerType && __indexOf.call(primTys, rty) >= 0) {
      printWarn("conversion from `" + rty + "' to pointer without cast");
      return lty;
    }
    if (__indexOf.call(primTys, lty) >= 0 && rty instanceof PointerType) {
      printWarn("conversion from pointer to `" + lty + "' without cast");
      return lty;
    }
    if (__indexOf.call(primTys, lty) >= 0 && __indexOf.call(primTys, rty) >= 0) {
      if (lty.size !== rty.size) {
        printWarn("conversion from `" + rty + "' to `" + lty + "' may alter its value");
        if (assign) {
          return lty;
        } else if (lty.size > rty.size) {
          return lty;
        } else {
          return rty;
        }
      }
      if (lty.signed !== rty.signed) {
        printWarn("conversion from `" + rty + "' to `" + lty + "' may alter its sign");
        return lty;
      }
    }
    return null;
  };

  Op.prototype.isAssignable = Op.prototype.isDeref = function() {
    return !this.second && this.operator === '*';
  };

  Base.prototype.computeType = function(r, o) {};

  Cast.prototype.computeType = function(r, o) {
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    return this.computedType = this.type.lint(o.types);
  };

  Literal.prototype.computeType = function(r, o) {
    var _ref2;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    return this.computedType = this.value === 'null' ? anyPtrTy : this.isAssignable() ? (_ref2 = o.scope.binding(this.value)) != null ? _ref2.type : void 0 : this.isSimpleNumber() ? intTy : void 0;
  };

  Assign.prototype.computeType = function(r, o) {
    var context, lty, rty, value;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    if (!(lty = this.variable.unwrapAll().computedType)) {
      return;
    }
    value = this.value.unwrapAll();
    if (lty instanceof PointerType && value instanceof Literal && value.value === '0') {
      value.computedType = anyPtrTy;
    }
    rty = value.computedType;
    context = this.context;
    if ((context === '+=' || context === '-=') && lty instanceof PointerType && __indexOf.call(primTys, rty) >= 0) {
      return this.computedType = lty;
    } else if (context === '-=' && lty instanceof PointerType && rty instanceof PointerType) {
      if (unify(o.types, lty.base, rty.base)) {
        return this.computedType = intTy;
      }
    }
    if (!(this.computedType = unify(o.types, lty, rty, true))) {
      throw TypeError("incompatible types: assigning `" + (tystr(rty)) + "' to `" + lty + "'");
    }
  };

  Value.prototype.computeType = function(r, o) {
    var baseTy, field, fieldName, prop, _i, _len, _ref2;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    if (baseTy = this.base.unwrapAll().computedType) {
      _ref2 = this.properties;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        prop = _ref2[_i];
        if (baseTy instanceof PointerType) {
          baseTy = baseTy.base;
        }
        if (!(baseTy instanceof StructType)) {
          return;
        }
        if (prop.soak) {
          throw TypeError("cannot soak struct field names");
        }
        fieldName = prop.name.unwrapAll().value;
        field = prop.computedField = baseTy.names[fieldName];
        if (!field) {
          throw TypeError("unknown struct field name `" + fieldName + "'");
        }
        baseTy = field.type;
      }
      return this.computedType = baseTy;
    }
  };

  Code.prototype.computeType = function(r, o) {
    var rexpr, rty, types, _i, _len, _ref2;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    this.spOffsets = spOffsetMap(o.scope);
    this.frameSize = o.scope.frameSize;
    types = o.types;
    _ref2 = returnExpressions(this.body);
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      rexpr = _ref2[_i];
      if (!rty) {
        rty = rexpr.unwrapAll().computedType;
      } else {
        rty = unify(types, rexpr.unwrapAll().computedType, rty);
      }
    }
    return this.computedType = new ArrowType(this.paramTypes, rty);
  };

  Call.prototype.computeType = function(r, o) {
    var args, aty, fty, i, paramTys, pty, types, _i, _len, _ref2, _ref3, _ref4;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    if (!(fty = (_ref2 = this.variable) != null ? _ref2.unwrapAll().computedType : void 0)) {
      return;
    }
    if (!(fty instanceof ArrowType)) {
      throw TypeError("calling a non-function type `" + fty + "'");
    }
    paramTys = fty.params;
    args = this.args;
    types = o.types;
    _ref3 = fty.params;
    for (i = _i = 0, _len = _ref3.length; _i < _len; i = ++_i) {
      pty = _ref3[i];
      aty = (_ref4 = args[i]) != null ? _ref4.computedType : void 0;
      if (pty && !unify(types, pty, aty, true)) {
        throw TypeError("incompatible types: passing arg `" + (tystr(aty)) + "' to param `" + (tystr(pty)) + "'");
      }
    }
    return this.computedType = fty.ret;
  };

  ARITH = ['+', '-', '*', '/'];

  BITWISE = ['<<', '>>', '>>>', '~', '&', '|'];

  COMPARE = ['===', '!==', '<', '>', '<=', '>='];

  Op.prototype.computeType = function(r, o) {
    var first, name, op, scope, tmp, ty1, ty2;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    op = this.operator;
    if (this.isUnary()) {
      first = this.first.unwrapAll();
      return this.computedType = (function() {
        if (op === 'new' && first.value in o.types) {
          ty1 = o.types[first.value];
          if (!(ty1 != null ? ty1.size : void 0)) {
            throw TypeError('cannot allocate type with size 0');
          }
          return new PointerType(ty1);
        } else if (op === 'delete' && (ty1 = first.computedType)) {
          if (!(ty1 instanceof PointerType)) {
            throw TypeError('cannot free non-pointer type');
          }
          return unitTy;
        } else if (op === 'sizeof') {
          ty1 = this.first = this.first.lint(o.types);
          if (!ty1.size) {
            throw TypeError("cannot determine size of type `" + ty1 + "'");
          }
          return intTy;
        } else if (op === '&' && (ty1 = first.computedType)) {
          if (!ty1) {
            throw TypeError("taking reference of an untyped expression:\n" + this.first);
          }
          if (ty1 instanceof ArrowType) {
            throw TypeError("taking reference of a function type");
          }
          if (!first.isAssignable()) {
            throw TypeError("taking reference of non-assignable");
          }
          if (first instanceof Literal) {
            name = first.value;
            scope = o.scope;
            if (!scope.check(name, true)) {
              throw TypeError("taking reference of non-local or undefined variable `" + name + "'");
            }
            putOnStack(scope, name);
          }
          return new PointerType(ty1);
        } else if (op === '*' && (ty1 = first.computedType)) {
          if (!ty1) {
            throw TypeError("dereferencing an untyped expression:\n" + this.first);
          }
          if (!(ty1 instanceof PointerType)) {
            throw TypeError("dereferencing a non-pointer type");
          }
          return ty1.base;
        } else if ((op === '++' || op === '--') && (ty1 = first.computedType)) {
          if (ty1 instanceof PointerType || __indexOf.call(primTys, ty1) >= 0) {
            return ty1;
          }
        }
      }).call(this);
    }
    ty1 = this.first.unwrapAll().computedType;
    ty2 = this.second.unwrapAll().computedType;
    if (ty2 instanceof PointerType) {
      tmp = ty1;
      ty1 = ty2;
      ty2 = tmp;
    }
    return this.computedType = (op === '+' || op === '-') && ty1 instanceof PointerType && __indexOf.call(primTys, ty2) >= 0 ? ty1 : op === '-' && ty1 instanceof PointerType && ty2 instanceof PointerType ? (!unify(o.types, ty1.base, ty2.base) ? printWarn("pointer subtraction on incompatible pointer types `" + ty1 + "' and `" + ty2 + "'") : void 0, intTy) : op === '%' ? intTy : __indexOf.call(COMPARE, op) >= 0 ? (ty1 instanceof PointerType && ty2 instanceof PointerType && !unify(o.types, ty1, ty2) ? printWarn("comparison between incompatible pointer types `" + ty1 + "' and `" + ty2 + "'") : void 0, intTy) : __indexOf.call(BITWISE, op) >= 0 ? intTy : __indexOf.call(ARITH, op) >= 0 && __indexOf.call(primTys, ty1) >= 0 && __indexOf.call(primTys, ty2) >= 0 ? unify(o.types, ty1, ty2) : void 0;
  };

  returnExpressions = function(body) {
    var exprs;
    exprs = body.expressions;
    return body.foldChildren([exprs[exprs.length - 1]], 'returnExpression', null, {});
  };

  undefExpr = new Value(new Literal('undefined'));

  Return.prototype.returnExpression = function(exprs, o) {
    exprs.push(this.expression || undefExpr);
    return exprs;
  };

  newTypedScope = function(p, e, m) {
    var scope;
    scope = new Scope(p, e, m);
    scope.variables.length = 0;
    scope.frameSize = 0;
    return scope;
  };

  Assign.prototype.primeComputeType = function(r, o) {
    var fn, name, ty, _ref2;
    if ((fn = this.value.unwrapAll()) instanceof Code && (name = this.variable.unwrapAll()) instanceof Literal && name.isAssignable() && (ty = (_ref2 = o.scope.binding(name.value)) != null ? _ref2.type : void 0) instanceof ArrowType) {
      if (fn.paramTypes == null) {
        fn.paramTypes = ty.params;
      }
      if (fn.returnType == null) {
        fn.returnType = ty.ret;
      }
    }
  };

  Code.prototype.primeComputeType = function(r, o) {
    var i, name, ptys, rexpr, rty, types, _i, _j, _len, _len1, _ref2, _ref3;
    rty = this.returnType;
    if (rty instanceof ArrowType) {
      _ref2 = returnExpressions(this.body);
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        rexpr = _ref2[_i];
        if (!(rexpr instanceof Code)) {
          continue;
        }
        rexpr = rexpr.unwrapAll();
        if (rexpr.paramTypes == null) {
          rexpr.paramTypes = rty.params;
        }
        if (rexpr.returnType == null) {
          rexpr.returnType = rty.ret;
        }
      }
    }
    o.scope = newTypedScope(o.scope, this.body, this);
    ptys = this.paramTypes;
    if (ptys) {
      if (ptys.length !== this.params.length) {
        throw TypeError("arrow type has different number of parameters than function");
      }
      types = o.types;
      _ref3 = this.params;
      for (i = _j = 0, _len1 = _ref3.length; _j < _len1; i = ++_j) {
        name = _ref3[i].name;
        if (!(name instanceof Literal)) {
          throw TypeError("cannot type complex parameter `" + name + "'");
        }
        ptys[i] = ptys[i].lint(types);
        (new DeclareType([new Value(name)], ptys[i])).declareType(r, o);
      }
    }
    this.body.foldChildren(null, 'declareType', null, {
      types: o.types,
      scope: o.scope
    });
  };

  DeclareType.prototype.declareType = function(r, o) {
    var name, scope, type, v, _i, _len, _ref2;
    type = this.type.lint(o.types);
    scope = o.scope;
    _ref2 = this.variables;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      v = _ref2[_i];
      name = v.unwrapAll().value;
      if (scope.check(name)) {
        throw TypeError("cannot redeclare typed variable `" + name + "'");
      }
      scope.add(name, new Binding(type));
      if (type instanceof StructType) {
        putOnStack(scope, name);
      }
    }
  };

  putOnStack = function(scope, name) {
    var bind;
    bind = scope.binding(name, true);
    bind.onStack = true;
    bind.spOffset = alignOffset(scope.frameSize, bind.type);
    return scope.frameSize += bind.spOffset + bind.type.size;
  };

  spOffsetMap = function(scope) {
    var bind, map, name, _i, _len, _ref2, _ref3;
    map = {};
    _ref2 = scope.variables;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      _ref3 = _ref2[_i], name = _ref3.name, bind = _ref3.type;
      if (bind.onStack) {
        map[name] = bind.spOffset;
      }
    }
    return map;
  };

  makeDeref = function(base, baseTy, offset, offsetTy) {
    return new Value(offsetTy.view, [new Index(offsetExpr(base, baseTy, offset, offsetTy))]);
  };

  inlineMemcpy = function(dest, src, ty, o) {
    var access, assign, destProp, destPtr, field, fty, i, offset, scope, srcProp, srcPtr, stmts, _i, _j, _len, _ref2, _ref3;
    scope = o.scope;
    stmts = [];
    destPtr = new Literal(scope.freeVariable('dest'));
    stmts.push(new Assign(new Value(destPtr), dest));
    srcPtr = new Literal(scope.freeVariable('src'));
    stmts.push(new Assign(new Value(srcPtr), src));
    if (ty instanceof StructType) {
      _ref2 = ty.fields;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        field = _ref2[_i];
        access = new Access(new Literal(field.name));
        access.computedField = field;
        fty = field.type;
        destProp = new Value(destPtr, [access]);
        destProp.computedType = fty;
        srcProp = new Value(srcPtr, [access]);
        srcProp.computedType = fty;
        assign = new Assign(destProp, srcProp);
        assign.computedType = fty;
        stmts.push(assign);
      }
    } else {
      for (i = _j = 0, _ref3 = ty.size; 0 <= _ref3 ? _j < _ref3 : _j > _ref3; i = 0 <= _ref3 ? ++_j : --_j) {
        offset = new Value(new Literal(i));
        stmts.push(new Assign(new Value(U8, [new Index(new Op('+', new Value(destPtr), offset))]), new Value(U8, [new Index(new Op('+', new Value(srcPtr), offset))])));
      }
    }
    stmts.push(new Value(destPtr));
    return new Value(new Parens(new Block(stmts)));
  };

  structLiteral = function(v, ty, o) {
    var access, field, fname, obj, propList, propValue, ptr, _i, _len, _ref2;
    ptr = new Literal(o.scope.freeVariable('ptr'));
    propList = [];
    _ref2 = ty.fields;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      field = _ref2[_i];
      fname = field.name;
      access = new Access(new Literal(fname));
      access.computedField = field;
      propValue = new Value(ptr, [access]);
      propValue.computedType = field.type;
      propList.push(new Assign(new Value(new Literal(fname)), propValue.transform(), 'object'));
    }
    obj = new Value(new Obj(propList));
    return new Value(new Parens(new Block([new Assign(new Value(ptr), v), obj])));
  };

  stackFence = function(exprs, frameSize, isRoot) {
    var restoreStack;
    exprs.unshift(new Assign(SP, normalizePtr(SPREAL, U32.BYTES_PER_ELEMENT, 1)));
    exprs.unshift(new Assign(SPREAL, new Value(new Literal(frameSize)), '-='));
    restoreStack = new Assign(SPREAL, new Value(new Literal(frameSize)), '+=');
    if (opts.unsafe) {
      if (isRoot) {
        exprs.push(restoreStack);
      }
    } else {
      exprs[0] = new Try(new Block(exprs.slice()), null, null, new Block([restoreStack]));
      exprs.length = 1;
    }
  };

  Cast.prototype.transform = function(r, o) {
    var lty, rty;
    lty = this.computedType;
    rty = this.expr.unwrapAll().computedType;
    if (!(lty instanceof PointerType && rty instanceof PointerType)) {
      return;
    }
    return normalizePtr(this.expr, lty.baseAlignment(), rty.baseAlignment());
  };

  Code.prototype.transform = function(o) {
    var frameSize, _ref2;
    o.returnType = (_ref2 = this.computedType) != null ? _ref2.ret : void 0;
    if (!(frameSize = this.frameSize)) {
      return;
    }
    o.spOffsets = this.spOffsets;
    o.frameSize = frameSize;
    stackFence(this.body.expressions, frameSize);
  };

  Return.prototype.transform = function(o) {
    var body, expr, frameSize, lalign, ralign, restoreStack, tmp, ty;
    if ((ty = o.returnType) && ty instanceof PointerType && (expr = this.expression)) {
      lalign = ty.baseAlignment();
      ralign = expr.unwrapAll().computedType.baseAlignment();
      this.expression = normalizePtr(this.expression, lalign, ralign);
    }
    if (!((frameSize = o.frameSize) && opts.unsafe)) {
      return;
    }
    restoreStack = new Assign(SPREAL, new Value(new Literal(frameSize)), '+=');
    if (expr = this.expression) {
      tmp = new Value(new Literal(o.scope.freeVariable('t')));
      body = [new Assign(tmp, expr), restoreStack, tmp];
    } else {
      body = [restoreStack, undefExpr];
    }
    this.expression = new Value(new Parens(new Block(body)));
  };

  Call.prototype.transform = function(o) {
    var args, fty, i, lalign, paramTys, pty, ralign, _i, _len, _ref2, _ref3;
    if (!(fty = (_ref2 = this.variable) != null ? _ref2.unwrapAll().computedType : void 0)) {
      return;
    }
    paramTys = fty.params;
    args = this.args;
    _ref3 = fty.params;
    for (i = _i = 0, _len = _ref3.length; _i < _len; i = ++_i) {
      pty = _ref3[i];
      if (pty instanceof PointerType) {
        lalign = pty.baseAlignment();
        ralign = args[i].computedType.baseAlignment();
        args[i] = normalizePtr(args[i], lalign, ralign);
      }
    }
  };

  Literal.prototype.transform = function(o) {
    var name, spOffsets, ty;
    if (!((ty = this.computedType) && o.frameSize)) {
      return;
    }
    spOffsets = o.spOffsets;
    if ((name = this.value) in spOffsets) {
      return new Value(U32, [new Index(stackOffsetExpr(spOffsets[name], ty))]);
    }
  };

  stackOffsetTransform = function(o) {
    return stackOffsetExpr(o.spOffsets[this.value], this.computedType);
  };

  Value.prototype.transform = function(o) {
    var base, cumulativeOffset, field, fty, inner, prop, props, v, vty, _i, _len, _ref2;
    if (!this.computedType) {
      return;
    }
    props = this.properties;
    if (!props.length) {
      return;
    }
    base = this.base;
    inner = base.unwrapAll();
    v = (typeof inner.isDeref === "function" ? inner.isDeref() : void 0) ? inner.first : inner.computedType instanceof PointerType ? base : (base.transform = stackOffsetTransform, base);
    vty = v.computedType;
    cumulativeOffset = 0;
    _ref2 = this.properties;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      prop = _ref2[_i];
      field = prop.computedField;
      if ((fty = field.type) instanceof StructType) {
        cumulativeOffset += field.offset;
      } else {
        v = makeDeref(v, vty, field.offset + cumulativeOffset, fty);
        vty = fty;
        cumulativeOffset = 0;
      }
    }
    if (fty instanceof StructType && cumulativeOffset !== 0) {
      return new Op('+', v, new Value(new Literal(cumulativeOffset)));
    } else {
      return v;
    }
  };

  Assign.prototype.transform = function(o) {
    var au, lalign, lty, lval, ralign, rty;
    if (!(lty = this.computedType)) {
      return;
    }
    if (lty instanceof PointerType) {
      rty = this.value.unwrapAll().computedType;
      if (rty instanceof PointerType) {
        lalign = lty.baseAlignment();
        ralign = rty.baseAlignment();
        this.value = normalizePtr(this.value, lalign, ralign);
      } else if (__indexOf.call(primTys, rty) >= 0 && (au = alignmentUnits(lty.base)) !== 1) {
        this.value = new Op('*', this.value, new Value(new Literal(au)));
      }
      return;
    }
    if (lty instanceof StructType) {
      lval = this.variable.unwrapAll();
      return inlineMemcpy(((typeof lval.isDeref === "function" ? lval.isDeref() : void 0) ? lval.first : this.variable), this.value, lty, o);
    }
  };

  Op.prototype.transform = function(o) {
    var au, inner, lalign, name, op, op1, op2, ralign, size, spOffsets, ty1, ty2;
    if (!this.computedType) {
      return;
    }
    op = this.operator;
    if (this.isUnary()) {
      if (op === 'new' && (ty1 = this.computedType)) {
        o.scope.root.needsMalloc = true;
        return new Call(MALLOC, [new Value(new Literal(ty.base.size))]);
      } else if (op === 'delete') {
        o.scope.root.needsMalloc = true;
        return new Call(FREE, [this.first]);
      } else if (op === 'sizeof') {
        return new Literal(this.first.size);
      } else if (op === '&' && (ty1 = this.computedType.base)) {
        if ((inner = this.first.unwrapAll()) instanceof Literal && o.frameSize) {
          spOffsets = o.spOffsets;
          if ((name = inner.value) in spOffsets) {
            return stackOffsetExpr(spOffsets[name], ty1);
          }
        } else {
          return this.first;
        }
      } else if (op === '*') {
        ty1 = this.first.computedType;
        return makeDeref(this.first, ty1, 0, ty1);
      } else if ((op === '++' || op === '--') && (ty1 = this.computedType) instanceof PointerType && (au = alignmentUnits(ty1.base)) !== 1) {
        size = new Value(new Literal(au));
        if (op === '++') {
          op1 = '+=';
          op2 = '-';
        } else {
          op1 = '-=';
          op2 = '-';
        }
        return new Value(new Parens(new Block([new Assign(this.first, size, op1), new Op(op2, this.first, size)])));
      }
    } else {
      ty1 = this.first.computedType;
      ty2 = this.second.computedType;
      if ((op === '+' || op === '-') && ((ty1 instanceof PointerType && __indexOf.call(primTys, ty2) >= 0 && (au = alignmentUnits(ty1.base)) !== 1) || (ty2 instanceof PointerType && __indexOf.call(primTys, ty1) >= 0 && (au = alignmentUnits(ty2.base)) !== 1))) {
        size = new Value(new Literal(au));
        if (ty1 instanceof PointerType) {
          return new Op(op, this.first, new Op('*', this.second, size));
        } else {
          return new Op(op, new Op('*', this.first, size), this.second);
        }
      } else if (__indexOf.call(COMPARE, op) >= 0 && ty1 instanceof PointerType && ty2 instanceof PointerType) {
        lalign = ty1.baseAlignment();
        ralign = ty2.baseAlignment();
        return new Op(op, this.first, normalizePtr(this.second, lalign, ralign));
      }
    }
  };

  PrimitiveType = (function() {

    function PrimitiveType(size, debugName, view, signed) {
      this.size = size;
      this.debugName = debugName;
      this.view = view;
      this.signed = signed;
    }

    PrimitiveType.prototype.lint = function(types) {
      return this;
    };

    PrimitiveType.prototype.toString = function() {
      return this.debugName;
    };

    return PrimitiveType;

  })();

  anyPtrTy = new PointerType(null);

  byteTy = new PrimitiveType(1, 'byte', U8, false);

  shortTy = new PrimitiveType(2, 'short', I16, true);

  intTy = new PrimitiveType(4, 'int', I32, true);

  uintTy = new PrimitiveType(4, 'uint', U32, false);

  primTys = [byteTy, shortTy, intTy, uintTy];

  SP.computedType = uintTy;

  SPREAL.computedType = byteTy;

  SPREAL.transform = null;

  requireExpr = function(name) {
    return new Call(new Value(new Literal('require')), [new Value(new Literal("'" + name + "'"))]);
  };

  exports.analyzeTypes = function(root, o) {
    var initialTypes, name, options, scope, ty, types, usesTypes;
    usesTypes = false;
    root.traverseChildren(true, function(node) {
      if (node instanceof DeclareType) {
        usesTypes = true;
        return false;
      }
    });
    if (!usesTypes) {
      return;
    }
    opts.warn = o.warn;
    opts.unsafe = o.unsafe;
    initialTypes = {
      any: null,
      byte: byteTy,
      short: shortTy,
      int: intTy,
      uint: uintTy
    };
    types = root.foldChildren(initialTypes, 'collectType', null, {
      immediate: true
    });
    for (name in types) {
      ty = types[name];
      if (ty) {
        types[name] = ty.lint(types);
      }
    }
    scope = newTypedScope(null, root, null);
    options = {
      types: types,
      scope: scope
    };
    root.foldChildren(null, 'declareType', null, options);
    options.crossScope = true;
    root.foldChildren(null, 'primeComputeType', 'computeType', options);
    root.spOffsets = spOffsetMap(scope);
    root.frameSize = scope.frameSize;
    root.transformRoot = function(o) {
      var exprs, frameSize, obj, props, view, _i, _len, _ref2;
      exprs = this.expressions;
      if (frameSize = scope.frameSize) {
        stackFence(this.expressions, frameSize, true);
      }
      if (scope.needsMalloc) {
        obj = new Value(new Obj([MALLOC, FREE]));
        exprs.unshift(new Assign(obj, requireExpr('heap/malloc')));
      }
      props = [];
      _ref2 = [I8, U8, I16, U16, I32, U32];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        view = _ref2[_i];
        props.push(new Value(view));
      }
      obj = new Value(new Obj(props));
      return exprs.unshift(new Assign(obj, requireExpr('heap/heap')));
    };
    return types;
  };

}).call(this);
