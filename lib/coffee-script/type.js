// Generated by CoffeeScript 1.3.1
(function() {
  var Access, ArrowType, Assign, Base, Binding, Block, Call, Cast, Code, Comment, DeclareType, FREE, HEAP, I16, I32, Index, Literal, MALLOC, MEMCPY, Obj, Op, Parens, PointerType, PrimitiveType, Return, SP, SPDEREF, Scope, StructType, Try, TypeAssign, TypeName, U16, U32, U8, Value, While, anyPtrTy, byteTy, extend, flatten, inlineMemcpy, intTy, lastNonCommentOrDeclaration, makeDeref, multExpr, newTypedScope, offsetExpr, opts, primTys, printWarn, putOnStack, requireExpr, returnExpressions, shortTy, spOffsetMap, stackFence, stackOffsetExpr, structLiteral, tystr, uintTy, undefExpr, unify, _ref, _ref1,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Scope = require('./scope').Scope;

  _ref = require('./nodes'), Base = _ref.Base, Parens = _ref.Parens, Block = _ref.Block, Value = _ref.Value, Literal = _ref.Literal, Op = _ref.Op, Assign = _ref.Assign, Try = _ref.Try, Code = _ref.Code, Index = _ref.Index, Access = _ref.Access, Call = _ref.Call, Return = _ref.Return, Obj = _ref.Obj, While = _ref.While, Comment = _ref.Comment, TypeAssign = _ref.TypeAssign, DeclareType = _ref.DeclareType, Cast = _ref.Cast, TypeName = _ref.TypeName, PointerType = _ref.PointerType, ArrowType = _ref.ArrowType, StructType = _ref.StructType;

  _ref1 = require('./helpers'), flatten = _ref1.flatten, extend = _ref1.extend, tystr = _ref1.tystr;

  HEAP = new Literal('_I8');

  U8 = new Literal('_U8');

  I16 = new Literal('_I16');

  U16 = new Literal('_U16');

  I32 = new Literal('_I32');

  U32 = new Literal('_U32');

  SP = new Value(new Literal('_SP'));

  SPDEREF = new Value(U32, [new Index(new Value(new Literal(1)))]);

  MALLOC = new Value(new Literal('malloc'));

  FREE = new Value(new Literal('free'));

  MEMCPY = new Value(new Literal('memcpy'));

  opts = {
    warn: false,
    unsafe: false
  };

  printWarn = function(line) {
    if (opts.warn) {
      return process.stderr.write('warning: ' + line + '\n');
    }
  };

  offsetExpr = function(base, offset, size) {
    var op, shiftBy;
    op = offset !== 0 ? new Op('+', base, new Value(new Literal(offset))) : base;
    shiftBy = Math.log(size) / Math.log(2);
    if (shiftBy !== 0) {
      return new Op('>>', op, new Literal(shiftBy));
    } else {
      return op;
    }
  };

  stackOffsetExpr = function(offset) {
    return offsetExpr(SP, offset, 1);
  };

  multExpr = function(base, size) {
    if (size && ((size & (size - 1)) === 0)) {
      return new Parens(new Op('<<', base, new Value(new Literal(Math.log(size) / Math.log(2)))));
    } else {
      return new Op('*', base, new Value(new Literal(size)));
    }
  };

  Binding = (function() {

    function Binding(type) {
      this.type = type;
    }

    return Binding;

  })();

  Scope.prototype.binding = function(name, immediate) {
    var found, _ref2;
    found = this.type(name);
    if (found || immediate) {
      return found;
    }
    return (_ref2 = this.parent) != null ? _ref2.binding(name) : void 0;
  };

  Base.prototype.foldChildren = function(r, pre, post, o) {
    var attr, child, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref2, _ref3, _ref4, _ref5;
    r = typeof this[pre] === 'function' ? this[pre](r, o) : r;
    if (!this.children) {
      return r;
    }
    if (o.immediate) {
      _ref2 = this.children;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        attr = _ref2[_i];
        if (this[attr]) {
          _ref3 = flatten([this[attr]]);
          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
            child = _ref3[_j];
            r = typeof child[pre] === 'function' ? child[pre](r, o) : r;
            r = post && typeof child[post] === 'function' ? child[post](r, o) : r;
          }
        }
      }
    } else {
      _ref4 = this.children;
      for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
        attr = _ref4[_k];
        if (this[attr]) {
          _ref5 = flatten([this[attr]]);
          for (_l = 0, _len3 = _ref5.length; _l < _len3; _l++) {
            child = _ref5[_l];
            r = child.foldChildren(r, pre, post, o);
          }
        }
      }
    }
    if (post && typeof this[post] === 'function') {
      return this[post](r, o);
    } else {
      return r;
    }
  };

  Code.prototype.foldChildren = function(r, pre, post, o) {
    if (!o.crossScope) {
      return r;
    }
    return Code.__super__.foldChildren.call(this, r, pre, post, extend({}, o));
  };

  TypeAssign.prototype.collectType = function(types) {
    types[this.name] = this.type;
    return types;
  };

  TypeName.prototype.lint = function(types) {
    var linted, _ref2;
    if (this.linting) {
      throw TypeError("circular type synonym: " + this.name);
    }
    if (this.linted) {
      return this.linted;
    }
    this.linting = true;
    if (!(this.name in types)) {
      throw TypeError("cannot resolve type `" + this.name + "'");
    }
    linted = (_ref2 = types[this.name]) != null ? _ref2.lint(types) : void 0;
    delete this.linting;
    return this.linted = linted;
  };

  PointerType.prototype.size = 4;

  PointerType.prototype.lint = function(types) {
    if (this.linted) {
      return this;
    }
    this.linted = true;
    this.base = this.base.lint(types);
    if (this.base instanceof ArrowType) {
      throw TypeError("cannot take pointers of function types");
    }
    return this;
  };

  StructType.prototype.lint = function(types) {
    var field, fields, offset, prev, s, size, _i, _j, _len, _len1;
    if (this.linted) {
      return this;
    }
    this.linted = true;
    fields = this.fields;
    for (_i = 0, _len = fields.length; _i < _len; _i++) {
      field = fields[_i];
      field.type = field.type.lint(types);
    }
    prev = {
      offset: 0,
      type: {
        size: 0
      }
    };
    size = 0;
    for (_j = 0, _len1 = fields.length; _j < _len1; _j++) {
      field = fields[_j];
      if ((offset = field.offset) != null) {
        if (offset < 0) {
          throw TypeError("struct field offsets cannot be negative");
        }
        if (offset < prev.offset) {
          printWarn("offset of field `" + field.name + "' is smaller offset of previous field");
        }
      } else if (field.usePreviousOffset) {
        field.offset = prev.offset;
      } else {
        field.offset = prev.offset + prev.type.size;
      }
      if ((s = field.offset + field.type.size) > size) {
        size = s;
      }
      prev = field;
    }
    this.size = size;
    return this;
  };

  ArrowType.prototype.lint = function(types) {
    var i, params, ty, _i, _len;
    if (this.linted) {
      return this;
    }
    this.linted = true;
    ty = this.ret.lint(types);
    this.ret = ty;
    params = this.params;
    for (i = _i = 0, _len = params.length; _i < _len; i = ++_i) {
      ty = params[i];
      params[i] = ty.lint(types);
    }
    return this;
  };

  unify = function(types, lty, rty, assign) {
    var i, lpty, lptys, ptys, rptys, _i, _len;
    if (lty === rty) {
      return lty;
    }
    if (!(lty && rty)) {
      return;
    }
    if (lty instanceof PointerType && rty instanceof PointerType) {
      if (assign && !rty.base) {
        return lty;
      }
      return new PointerType(unify(types, lty.base, rty.base, assign));
    }
    if (lty instanceof ArrowType && rty instanceof ArrowType) {
      lptys = lty.params;
      rptys = rty.params;
      if (lptys.length !== rptys.length) {
        return;
      }
      ptys = [];
      for (i = _i = 0, _len = lptys.length; _i < _len; i = ++_i) {
        lpty = lptys[i];
        ptys.push(unify(types, lpty, rptys[i], assign));
      }
      return new ArrowType(ptys, unify(types, lty.ret, rty.ret, assign));
    }
    if (lty instanceof PointerType && __indexOf.call(primTys, rty) >= 0) {
      printWarn("conversion from `" + rty + "' to pointer without cast");
      return lty;
    }
    if (__indexOf.call(primTys, lty) >= 0 && rty instanceof PointerType) {
      printWarn("conversion from pointer to `" + lty + "' without cast");
      return lty;
    }
    if (__indexOf.call(primTys, lty) >= 0 && __indexOf.call(primTys, rty) >= 0) {
      if (lty.size !== rty.size) {
        printWarn("conversion from `" + rty + "' to `" + lty + "' may alter its value");
        if (assign) {
          return lty;
        } else if (lty.size > rty.size) {
          return lty;
        } else {
          return rty;
        }
      }
      if (lty.signed !== rty.signed) {
        printWarn("conversion from `" + rty + "' to `" + lty + "' may alter its sign");
        return lty;
      }
    }
    return null;
  };

  Op.prototype.isDeref = function() {
    return !this.second && this.operator === '*';
  };

  Base.prototype.computeType = function(r, o) {};

  Cast.prototype.computeType = function(r, o) {
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    return this.computedType = this.type.lint(o.types);
  };

  Literal.prototype.computeType = function(r, o) {
    var _ref2;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    return this.computedType = this.value === 'null' ? anyPtrTy : this.isAssignable() ? (_ref2 = o.scope.binding(this.value)) != null ? _ref2.type : void 0 : this.isSimpleNumber() ? intTy : void 0;
  };

  Assign.prototype.computeType = function(r, o) {
    var context, lty, rty, value;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    if (!(lty = this.variable.unwrapAll().computedType)) {
      return;
    }
    value = this.value.unwrapAll();
    if (lty instanceof PointerType && value instanceof Literal && value.value === '0') {
      value.computedType = anyPtrTy;
    }
    rty = value.computedType;
    context = this.context;
    if ((context === '+=' || context === '-=') && lty instanceof PointerType && __indexOf.call(primTys, rty) >= 0) {
      return this.computedType = lty;
    } else if (context === '-=' && lty instanceof PointerType && rty instanceof PointerType) {
      if (unify(o.types, lty.base, rty.base)) {
        return this.computedType = intTy;
      }
    }
    if (!(this.computedType = unify(o.types, lty, rty, true))) {
      console.log(this.variable);
      console.log(this.value);
      throw TypeError("incompatible types: assigning `" + (tystr(rty)) + "' to `" + lty + "'");
    }
  };

  Value.prototype.computeType = function(r, o) {
    var baseTy, field, fieldName, prop, _i, _len, _ref2;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    if (baseTy = this.base.unwrapAll().computedType) {
      _ref2 = this.properties;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        prop = _ref2[_i];
        if (baseTy instanceof PointerType) {
          baseTy = baseTy.base;
        }
        if (!(baseTy instanceof StructType)) {
          return;
        }
        if (prop.soak) {
          throw TypeError("cannot soak struct field names");
        }
        fieldName = prop.name.unwrapAll().value;
        field = prop.computedField = baseTy.names[fieldName];
        if (!field) {
          throw TypeError("unknown struct field name `" + fieldName + "'");
        }
        baseTy = field.type;
      }
      return this.computedType = baseTy;
    }
  };

  Code.prototype.computeType = function(r, o) {
    var rexpr, rty, types, _i, _len, _ref2;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    this.spOffsets = spOffsetMap(o.scope);
    this.frameSize = o.scope.frameSize;
    types = o.types;
    _ref2 = returnExpressions(this.body);
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      rexpr = _ref2[_i];
      if (!rty) {
        rty = rexpr.unwrapAll().computedType;
      } else {
        rty = unify(types, rexpr.unwrapAll().computedType, rty);
      }
    }
    return this.computedType = new ArrowType(this.paramTypes, rty);
  };

  Call.prototype.computeType = function(r, o) {
    var args, aty, f, fty, i, paramTys, pty, types, _i, _len, _ref2, _ref3;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    f = this.variable.unwrapAll();
    if (!(fty = f.computedType)) {
      return;
    }
    if (!(fty instanceof ArrowType)) {
      throw TypeError("calling a non-function type `" + fty + "'");
    }
    paramTys = fty.params;
    args = this.args;
    types = o.types;
    _ref2 = fty.params;
    for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {
      pty = _ref2[i];
      aty = (_ref3 = args[i]) != null ? _ref3.computedType : void 0;
      if (pty && !unify(types, pty, aty, true)) {
        throw TypeError("incompatible types: passing arg `" + (tystr(aty)) + "' to param `" + (tystr(pty)) + "'");
      }
    }
    return this.computedType = fty.ret;
  };

  Op.prototype.computeType = function(r, o) {
    var ARITH_OPS, BITWISE_OPS, first, name, op, scope, tmp, ty1, ty2;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    op = this.operator;
    if (this.isUnary()) {
      first = this.first.unwrapAll();
      return this.computedType = (function() {
        if (op === 'new' && first.value in o.types) {
          ty1 = o.types[first.value];
          if (!(ty1 != null ? ty1.size : void 0)) {
            throw TypeError('cannot allocate type with size 0');
          }
          return new PointerType(ty1);
        } else if (op === 'delete' && (ty1 = first.computedType)) {
          if (!(ty1 instanceof PointerType)) {
            throw TypeError('cannot free non-pointer type');
          }
          return unitTy;
        } else if (op === 'sizeof') {
          ty1 = this.first = this.first.lint(o.types);
          if (!ty1.size) {
            throw TypeError("cannot determine size of type `" + ty1 + "'");
          }
          return intTy;
        } else if (op === '&' && (ty1 = first.computedType)) {
          if (!ty1) {
            throw TypeError("taking reference of an untyped expression:\n" + this.first);
          }
          if (ty1 instanceof ArrowType) {
            throw TypeError("taking reference of a function type");
          }
          if (!first.isAssignable()) {
            throw TypeError("taking reference of non-assignable");
          }
          if (first instanceof Literal) {
            name = first.value;
            scope = o.scope;
            if (!scope.check(name, true)) {
              throw TypeError("taking reference of non-local or undefined variable `" + name + "'");
            }
            putOnStack(scope, name);
          }
          return new PointerType(ty1);
        } else if (op === '*' && (ty1 = first.computedType)) {
          if (!ty1) {
            throw TypeError("dereferencing an untyped expression:\n" + this.first);
          }
          if (!(ty1 instanceof PointerType)) {
            throw TypeError("dereferencing a non-pointer type");
          }
          return ty1.base;
        } else if ((op === '++' || op === '--') && (ty1 = first.computedType)) {
          if (ty1 instanceof PointerType || __indexOf.call(primTys, ty1) >= 0) {
            return ty1;
          }
        }
      }).call(this);
    }
    ty1 = this.first.unwrapAll().computedType;
    ty2 = this.second.unwrapAll().computedType;
    if (ty2 instanceof PointerType) {
      tmp = ty1;
      ty1 = ty2;
      ty2 = tmp;
    }
    ARITH_OPS = ['+', '-', '*', '/'];
    BITWISE_OPS = ['<<', '>>', '>>>', '~', '&', '|'];
    return this.computedType = (op === '+' || op === '-') && ty1 instanceof PointerType && __indexOf.call(primTys, ty2) >= 0 ? ty1 : op === '-' && ty1 instanceof PointerType && ty2 instanceof PointerType ? unify(o.types, ty1.base, ty2.base) ? intTy : void 0 : op === '%' ? intTy : __indexOf.call(BITWISE_OPS, op) >= 0 ? intTy : __indexOf.call(ARITH_OPS, op) >= 0 && __indexOf.call(primTys, ty1) >= 0 && __indexOf.call(primTys, ty2) >= 0 ? unify(o.types, ty1, ty2) : void 0;
  };

  returnExpressions = function(body) {
    var exprs;
    exprs = body.expressions;
    return body.foldChildren([exprs[exprs.length - 1]], 'returnExpression', null, {});
  };

  undefExpr = new Value(new Literal('undefined'));

  Return.prototype.returnExpression = function(exprs, o) {
    exprs.push(this.expression || undefExpr);
    return exprs;
  };

  newTypedScope = function(p, e, m) {
    var scope;
    scope = new Scope(p, e, m);
    scope.variables.length = 0;
    scope.frameSize = 0;
    return scope;
  };

  Assign.prototype.primeComputeType = function(r, o) {
    var fn, name, ty, _ref2;
    if ((fn = this.value.unwrapAll()) instanceof Code && (name = this.variable.unwrapAll()) instanceof Literal && name.isAssignable() && (ty = (_ref2 = o.scope.binding(name.value)) != null ? _ref2.type : void 0) instanceof ArrowType) {
      if (fn.paramTypes == null) {
        fn.paramTypes = ty.params;
      }
      if (fn.returnType == null) {
        fn.returnType = ty.ret;
      }
    }
  };

  Code.prototype.primeComputeType = function(r, o) {
    var i, name, ptys, rexpr, rty, types, _i, _j, _len, _len1, _ref2, _ref3;
    rty = this.returnType;
    if (rty instanceof ArrowType) {
      _ref2 = returnExpressions(this.body);
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        rexpr = _ref2[_i];
        if (!(rexpr instanceof Code)) {
          continue;
        }
        rexpr = rexpr.unwrapAll();
        if (rexpr.paramTypes == null) {
          rexpr.paramTypes = rty.params;
        }
        if (rexpr.returnType == null) {
          rexpr.returnType = rty.ret;
        }
      }
    }
    o.scope = newTypedScope(o.scope, this.body, this);
    ptys = this.paramTypes;
    if (ptys) {
      if (ptys.length !== this.params.length) {
        throw TypeError("arrow type has different number of parameters than function");
      }
      types = o.types;
      _ref3 = this.params;
      for (i = _j = 0, _len1 = _ref3.length; _j < _len1; i = ++_j) {
        name = _ref3[i].name;
        if (!(name instanceof Literal)) {
          throw TypeError("cannot type complex parameter `" + name + "'");
        }
        ptys[i] = ptys[i].lint(types);
        (new DeclareType([new Value(name)], ptys[i])).declareType(r, o);
      }
    }
    this.body.foldChildren(null, 'declareType', null, {
      types: o.types,
      scope: o.scope
    });
  };

  DeclareType.prototype.declareType = function(r, o) {
    var name, scope, type, v, _i, _len, _ref2;
    type = this.type.lint(o.types);
    scope = o.scope;
    _ref2 = this.variables;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      v = _ref2[_i];
      name = v.unwrapAll().value;
      if (scope.check(name)) {
        throw TypeError("cannot redeclare typed variable `" + name + "'");
      }
      scope.add(name, new Binding(type));
      if (type instanceof StructType) {
        putOnStack(scope, name);
      }
    }
  };

  putOnStack = function(scope, name) {
    var bind;
    bind = scope.binding(name, true);
    bind.onStack = true;
    bind.spOffset = scope.frameSize;
    return scope.frameSize += bind.type.size;
  };

  spOffsetMap = function(scope) {
    var bind, map, name, _i, _len, _ref2, _ref3;
    map = {};
    _ref2 = scope.variables;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      _ref3 = _ref2[_i], name = _ref3.name, bind = _ref3.type;
      if (bind.onStack) {
        map[name] = bind.spOffset;
      }
    }
    return map;
  };

  makeDeref = function(base, offset, ty) {
    if (!ty.view) {
      throw TypeError("unknown view on type `" + ty + "'");
    }
    return new Value(ty.view, [new Index(offsetExpr(base, offset, ty.size))]);
  };

  inlineMemcpy = function(dest, src, ty, o) {
    var access, assign, destProp, destPtr, field, fty, i, offset, scope, srcProp, srcPtr, stmts, _i, _j, _len, _ref2, _ref3;
    scope = o.scope;
    stmts = [];
    destPtr = new Literal(scope.freeVariable('dest'));
    stmts.push(new Assign(new Value(destPtr), dest));
    srcPtr = new Literal(scope.freeVariable('src'));
    stmts.push(new Assign(new Value(srcPtr), src));
    if (ty instanceof StructType) {
      _ref2 = ty.fields;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        field = _ref2[_i];
        access = new Access(new Literal(field.name));
        access.computedField = field;
        fty = field.type;
        destProp = new Value(destPtr, [access]);
        destProp.computedType = fty;
        srcProp = new Value(srcPtr, [access]);
        srcProp.computedType = fty;
        assign = new Assign(destProp, srcProp);
        assign.computedType = fty;
        stmts.push(assign);
      }
    } else {
      for (i = _j = 0, _ref3 = ty.size; 0 <= _ref3 ? _j < _ref3 : _j > _ref3; i = 0 <= _ref3 ? ++_j : --_j) {
        offset = new Value(new Literal(i));
        stmts.push(new Assign(new Value(HEAP, [new Index(new Op('+', new Value(destPtr), offset))]), new Value(HEAP, [new Index(new Op('+', new Value(srcPtr), offset))])));
      }
    }
    stmts.push(new Value(destPtr));
    return new Value(new Parens(new Block(stmts)));
  };

  structLiteral = function(v, ty, o) {
    var access, field, fname, obj, propList, propValue, ptr, _i, _len, _ref2;
    ptr = new Literal(o.scope.freeVariable('ptr'));
    propList = [];
    _ref2 = ty.fields;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      field = _ref2[_i];
      fname = field.name;
      access = new Access(new Literal(fname));
      access.computedField = field;
      propValue = new Value(ptr, [access]);
      propValue.computedType = field.type;
      propList.push(new Assign(new Value(new Literal(fname)), propValue.transform(), 'object'));
    }
    obj = new Value(new Obj(propList));
    return new Value(new Parens(new Block([new Assign(new Value(ptr), v), obj])));
  };

  lastNonCommentOrDeclaration = function(list) {
    var i;
    i = list.length;
    while (i--) {
      if (!(list[i] instanceof Comment) && !(list[i] instanceof DeclareType) && !(list[i] instanceof TypeAssign)) {
        return i;
      }
    }
  };

  stackFence = function(o, exprs, frameSize, isRoot) {
    var restoreStack;
    exprs.unshift(new Assign(SP, SPDEREF));
    exprs.unshift(new Assign(SPDEREF, new Value(new Literal(frameSize)), '-='));
    restoreStack = new Assign(SPDEREF, new Value(new Literal(frameSize)), '+=');
    if (opts.unsafe) {
      if (isRoot) {
        exprs.push(restoreStack);
      }
    } else {
      exprs[0] = new Try(new Block(exprs.slice()), null, null, new Block([restoreStack]));
      exprs.length = 1;
    }
  };

  Code.prototype.transform = function(o) {
    var frameSize;
    if (!(frameSize = this.frameSize)) {
      return;
    }
    stackFence(o, this.body.expressions, frameSize);
  };

  Return.prototype.transform = function(o) {
    var body, expr, frameSize, restoreStack, tmp;
    if (!((frameSize = o.frameSize) && opts.unsafe)) {
      return;
    }
    restoreStack = new Assign(SPDEREF, new Value(new Literal(frameSize)), '+=');
    if (expr = this.expression) {
      tmp = new Value(new Literal(o.scope.freeVariable('t')));
      body = [new Assign(tmp, expr), restoreStack, tmp];
    } else {
      body = [restoreStack, undefExpr];
    }
    this.expression = new Value(new Parens(new Block(body)));
  };

  Value.prototype.transform = function(o) {
    var base, cumulativeOffset, field, inner, name, prop, props, spOffsets, stackDeref, ty, v, _i, _len, _ref2;
    if (!this.computedType) {
      return;
    }
    base = this.base;
    inner = base.unwrapAll();
    props = this.properties;
    if (inner instanceof Literal && o.frameSize) {
      spOffsets = o.spOffsets;
      if ((name = inner.value) in spOffsets) {
        stackDeref = stackOffsetExpr(spOffsets[name]);
        if (props.length) {
          base = stackDeref;
        } else {
          return stackDeref;
        }
      }
    }
    if (!props.length) {
      return;
    }
    v = (typeof inner.isDeref === "function" ? inner.isDeref() : void 0) ? inner.first : base;
    cumulativeOffset = 0;
    _ref2 = this.properties;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      prop = _ref2[_i];
      field = prop.computedField;
      if ((ty = field.type) instanceof StructType) {
        cumulativeOffset += field.offset;
      } else {
        v = makeDeref(v, field.offset + cumulativeOffset, ty);
        cumulativeOffset = 0;
      }
    }
    if (ty instanceof StructType && cumulativeOffset !== 0) {
      return new Op('+', v, new Value(new Literal(cumulativeOffset)));
    } else {
      return v;
    }
  };

  Assign.prototype.transform = function(o) {
    var context, lty, lval, rty, ty;
    if (!(ty = this.computedType)) {
      return;
    }
    lval = this.variable.unwrapAll();
    context = this.context;
    if (context === '+=' || context === '-=') {
      lty = lval.computedType;
      rty = this.value.unwrapAll().computedType;
      if (lty instanceof PointerType && __indexOf.call(primTys, rty) >= 0) {
        this.value = multExpr(this.value, lty.base.size);
      } else if (lty instanceof PointerType && rty instanceof PointerType) {
        return offsetExpr(this, 0, lty.base.size);
      }
    } else if (ty instanceof StructType) {
      return inlineMemcpy(((typeof lval.isDeref === "function" ? lval.isDeref() : void 0) ? lval.first : this.variable), this.value, ty, o);
    }
  };

  Op.prototype.transform = function(o) {
    var op, size, ty1, ty2;
    if (!this.computedType) {
      return;
    }
    op = this.operator;
    if (this.isUnary()) {
      if (op === 'new' && (ty1 = this.computedType)) {
        o.scope.root.needsMalloc = true;
        return new Call(MALLOC, [new Value(new Literal(ty.base.size))]);
      } else if (op === 'delete') {
        o.scope.root.needsMalloc = true;
        return new Call(FREE, [this.first]);
      } else if (op === 'sizeof') {
        return new Literal(this.first.size);
      } else if (op === '&') {
        return this.first;
      } else if (op === '*') {
        return makeDeref(this.first, 0, this.first.computedType);
      } else if ((op === '++' || op === '--') && (ty1 = this.computedType) instanceof PointerType) {
        size = new Value(new Literal(ty1.base.size));
        return new Value(new Parens(new Block([new Assign(this.first, size, '+='), new Op('-', this.first, size)])));
      }
    } else {
      ty1 = this.first.computedType;
      ty2 = this.second.computedType;
      if ((op === '+' || op === '-') && ty1 instanceof PointerType && __indexOf.call(primTys, ty2) >= 0) {
        return new Op(op, this.first, multExpr(this.second, ty1.base.size));
      } else if ((op === '+' || op === '-') && __indexOf.call(primTys, ty1) >= 0 && ty2 instanceof PointerType) {
        return new Op(op, multExpr(this.first, ty2.base.size), this.second);
      } else if (op === '-' && ty1 instanceof PointerType) {
        this.transform = null;
        return offsetExpr(this, 0, ty1.base.size);
      }
    }
  };

  PointerType.prototype.view = U32;

  PrimitiveType = (function() {

    function PrimitiveType(size, debugName, view, signed) {
      this.size = size;
      this.debugName = debugName;
      this.view = view;
      this.signed = signed;
    }

    PrimitiveType.prototype.lint = function(types) {
      return this;
    };

    PrimitiveType.prototype.toString = function() {
      return this.debugName;
    };

    return PrimitiveType;

  })();

  anyPtrTy = new PointerType(null);

  byteTy = new PrimitiveType(1, 'byte', HEAP, true);

  shortTy = new PrimitiveType(2, 'short', I16, true);

  intTy = new PrimitiveType(4, 'int', I32, true);

  uintTy = new PrimitiveType(4, 'uint', U32, false);

  primTys = [byteTy, shortTy, intTy, uintTy];

  requireExpr = function(name) {
    return new Call(new Value(new Literal('require')), [new Value(new Literal("'" + name + "'"))]);
  };

  exports.analyzeTypes = function(root, o) {
    var initialTypes, name, options, scope, ty, types, usesTypes;
    usesTypes = false;
    root.traverseChildren(true, function(node) {
      if (node instanceof DeclareType) {
        usesTypes = true;
        return false;
      }
    });
    if (!usesTypes) {
      return;
    }
    opts.warn = o.warn;
    opts.unsafe = o.unsafe;
    initialTypes = {
      any: null,
      byte: byteTy,
      short: shortTy,
      int: intTy,
      uint: uintTy
    };
    types = root.foldChildren(initialTypes, 'collectType', null, {
      immediate: true
    });
    for (name in types) {
      ty = types[name];
      if (ty) {
        types[name] = ty.lint(types);
      }
    }
    scope = newTypedScope(null, root, null);
    options = {
      types: types,
      scope: scope
    };
    root.foldChildren(null, 'declareType', null, options);
    options.crossScope = true;
    root.foldChildren(null, 'primeComputeType', 'computeType', options);
    root.spOffsets = spOffsetMap(scope);
    root.frameSize = scope.frameSize;
    root.transformRoot = function(o) {
      var exprs, frameSize, obj, props, view, _i, _len, _ref2;
      exprs = this.expressions;
      if (frameSize = scope.frameSize) {
        stackFence(o, this.expressions, frameSize, true);
      }
      if (scope.needsMalloc) {
        obj = new Value(new Obj([MALLOC, FREE]));
        exprs.unshift(new Assign(obj, requireExpr('heap/malloc')));
      }
      props = [];
      _ref2 = [HEAP, U8, I16, U16, I32, U32];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        view = _ref2[_i];
        props.push(new Value(view));
      }
      obj = new Value(new Obj(props));
      return exprs.unshift(new Assign(obj, requireExpr('heap/heap')));
    };
    return types;
  };

}).call(this);
