// Generated by CoffeeScript 1.3.1
(function() {
  var ARITH, Access, ArrowType, Assign, BITWISE, Base, Binding, Block, COMPARE, Call, Cast, Code, Comment, DeclareType, F32, F32V, F64, F64V, FREE, HEAP, I16, I16V, I32, I32V, I8, I8V, If, Index, Literal, MALLOC, MEMCPY, Obj, Op, Parens, PointerType, PrimitiveType, Return, SP, SPREAL, Scope, StructType, Switch, Try, TypeAssign, TypeName, U16, U16V, U32, U32V, U8, U8V, Value, While, alignOffset, alignmentUnits, anyPtrTy, binopType, coerceIntegral, extend, f64ty, flatten, i16ty, i32ty, i8ty, inlineMemcpy, integral, makeDeref, multExpr, newTypedScope, normalizePtr, numeric, offsetExpr, opts, printWarn, putOnStack, recorderForView, requireExpr, returnExpressions, spOffsets, stackFence, stackOffsetExpr, structLiteral, tystr, u16ty, u32ty, u8ty, undefExpr, unify, _ref, _ref1,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Scope = require('./scope').Scope;

  _ref = require('./nodes'), Base = _ref.Base, Parens = _ref.Parens, Block = _ref.Block, Value = _ref.Value, Literal = _ref.Literal, Op = _ref.Op, Assign = _ref.Assign, Try = _ref.Try, If = _ref.If, Switch = _ref.Switch, Code = _ref.Code, Index = _ref.Index, Access = _ref.Access, Call = _ref.Call, Return = _ref.Return, Obj = _ref.Obj, While = _ref.While, Comment = _ref.Comment, TypeAssign = _ref.TypeAssign, DeclareType = _ref.DeclareType, Cast = _ref.Cast, TypeName = _ref.TypeName, PointerType = _ref.PointerType, ArrowType = _ref.ArrowType, StructType = _ref.StructType;

  _ref1 = require('./helpers'), flatten = _ref1.flatten, extend = _ref1.extend, tystr = _ref1.tystr;

  HEAP = new Value(new Literal('_HEAP'));

  I8V = new Literal('_I8');

  U8V = new Literal('_U8');

  I16V = new Literal('_I16');

  U16V = new Literal('_U16');

  I32V = new Literal('_I32');

  U32V = new Literal('_U32');

  F32V = new Literal('_F32');

  F64V = new Literal('_F64');

  SP = new Value(new Literal('_SP'));

  SPREAL = new Value(U32V, [new Index(new Value(new Literal(1)))]);

  MALLOC = new Value(new Literal('malloc'));

  FREE = new Value(new Literal('free'));

  MEMCPY = new Value(new Literal('memcpy'));

  recorderForView = function(view) {
    return function(o) {
      var name;
      name = view.value;
      o.scope.assign(name, "" + HEAP.base.value + "." + (name.substr(name.lastIndexOf('_') + 1)));
      return view;
    };
  };

  I8 = recorderForView(I8V);

  U8 = recorderForView(U8V);

  I16 = recorderForView(I16V);

  U16 = recorderForView(U16V);

  I32 = recorderForView(I32V);

  U32 = recorderForView(U32V);

  F32 = recorderForView(F32V);

  F64 = recorderForView(F64V);

  I8.BYTES_PER_ELEMENT = U8.BYTES_PER_ELEMENT = 1;

  I16.BYTES_PER_ELEMENT = U16.BYTES_PER_ELEMENT = 2;

  I32.BYTES_PER_ELEMENT = U32.BYTES_PER_ELEMENT = 4;

  F32.BYTES_PER_ELEMENT = 4;

  F64.BYTES_PER_ELEMENT = 8;

  opts = {
    warn: false,
    unsafe: false
  };

  printWarn = function(line) {
    if (opts.warn) {
      return process.stderr.write('warning: ' + line + '\n');
    }
  };

  normalizePtr = function(ptr, lalign, ralign) {
    var inner, op, ratio;
    if (lalign === ralign || ((inner = ptr.unwrapAll()) instanceof Literal && inner.value === '0' || inner.value === 'null')) {
      return ptr;
    }
    if (lalign < ralign) {
      ratio = ralign / lalign;
      op = '<<';
    } else {
      ratio = lalign / ralign;
      op = '>>';
    }
    return new Parens(new Op(op, ptr, new Value(new Literal(Math.log(ratio) / Math.log(2)))));
  };

  offsetExpr = function(base, baseTy, offset, offsetTy) {
    var balign, normalized, oalign;
    balign = baseTy.view.BYTES_PER_ELEMENT;
    oalign = offsetTy.view.BYTES_PER_ELEMENT;
    normalized = normalizePtr(base, balign, oalign);
    if (offset !== 0) {
      return new Op('+', normalized, new Value(new Literal(offset / oalign)));
    } else {
      return normalized;
    }
  };

  stackOffsetExpr = function(offset, offsetTy) {
    return offsetExpr(SP, SP.computedType, offset, offsetTy);
  };

  multExpr = function(base, size) {
    if (size && ((size & (size - 1)) === 0)) {
      return new Parens(new Op('<<', base, new Value(new Literal(Math.log(size) / Math.log(2)))));
    } else {
      return new Op('*', base, new Value(new Literal(size)));
    }
  };

  Binding = (function() {

    function Binding(type) {
      this.type = type;
    }

    return Binding;

  })();

  Scope.prototype.binding = function(name, immediate) {
    var found, _ref2;
    found = this.type(name);
    if (found || immediate) {
      return found;
    }
    return (_ref2 = this.parent) != null ? _ref2.binding(name) : void 0;
  };

  Base.prototype.foldChildren = function(r, pre, post, o) {
    var attr, child, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref2, _ref3, _ref4, _ref5;
    r = typeof this[pre] === 'function' ? this[pre](r, o) : r;
    if (!this.children) {
      return r;
    }
    if (o.immediate) {
      _ref2 = this.children;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        attr = _ref2[_i];
        if (this[attr]) {
          _ref3 = flatten([this[attr]]);
          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
            child = _ref3[_j];
            r = typeof child[pre] === 'function' ? child[pre](r, o) : r;
            r = post && typeof child[post] === 'function' ? child[post](r, o) : r;
          }
        }
      }
    } else {
      _ref4 = this.children;
      for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
        attr = _ref4[_k];
        if (this[attr]) {
          _ref5 = flatten([this[attr]]);
          for (_l = 0, _len3 = _ref5.length; _l < _len3; _l++) {
            child = _ref5[_l];
            r = child.foldChildren(r, pre, post, o);
          }
        }
      }
    }
    if (post && typeof this[post] === 'function') {
      return this[post](r, o);
    } else {
      return r;
    }
  };

  Code.prototype.foldChildren = function(r, pre, post, o) {
    if (!o.crossScope) {
      return r;
    }
    return Code.__super__.foldChildren.call(this, r, pre, post, extend({}, o));
  };

  TypeAssign.prototype.collectType = function(types) {
    types[this.name] = this.type;
    return types;
  };

  alignOffset = function(offset, ty) {
    var size;
    size = ty.view.BYTES_PER_ELEMENT;
    return (((offset - 1) / size + 1) | 0) * size;
  };

  alignmentUnits = function(ty) {
    return ty.size / ty.view.BYTES_PER_ELEMENT;
  };

  TypeName.prototype.lint = function(types) {
    var linted, _ref2;
    if (this.linting) {
      throw TypeError("circular type synonym: " + this.name);
    }
    if (this.linted) {
      return this.linted;
    }
    this.linting = true;
    if (!(this.name in types)) {
      throw TypeError("cannot resolve type `" + this.name + "'");
    }
    linted = (_ref2 = types[this.name]) != null ? _ref2.lint(types) : void 0;
    delete this.linting;
    return this.linted = linted;
  };

  PointerType.prototype.size = 4;

  PointerType.prototype.view = U32;

  PointerType.prototype.baseAlignment = function() {
    var _ref2;
    return ((_ref2 = this.base) != null ? _ref2.view.BYTES_PER_ELEMENT : void 0) || 1;
  };

  PointerType.prototype.lint = function(types) {
    var base;
    if (this.linted) {
      return this;
    }
    this.linted = true;
    this.base = base = this.base.lint(types);
    if (base && !base.size) {
      throw TypeError("cannot take pointers of unsized type `" + base + "'");
    }
    return this;
  };

  PointerType.prototype.coerce = function(expr) {
    var ty;
    ty = expr.unwrapAll().computedType;
    if (!(ty instanceof PointerType && ty !== this)) {
      return expr;
    }
    return normalizePtr(expr, this.baseAlignment(), ty.baseAlignment());
  };

  StructType.prototype.lint = function(types) {
    var align, field, field2, fields, maxView, offset, prev, s, size, ty, ty2, _i, _j, _k, _l, _len, _len1, _len2, _len3;
    if (this.linted) {
      return this;
    }
    this.linted = true;
    this.size = 1;
    fields = this.fields;
    for (_i = 0, _len = fields.length; _i < _len; _i++) {
      field = fields[_i];
      field.type = field.type.lint(types);
    }
    prev = {
      offset: 0,
      type: {
        size: 0
      }
    };
    size = 0;
    maxView = U8;
    for (_j = 0, _len1 = fields.length; _j < _len1; _j++) {
      field = fields[_j];
      ty = field.type;
      if (!ty.size) {
        throw TypeError("cannot store unsized type `" + ty + "' as a struct field");
      }
      if (ty.view.BYTES_PER_ELEMENT > maxView.BYTES_PER_ELEMENT) {
        maxView = ty.view;
      }
      if ((offset = field.offset) != null) {
        if (offset < 0) {
          throw TypeError("struct field offsets cannot be negative");
        }
        if (offset < prev.offset) {
          printWarn("offset of field `" + field.name + "' is smaller offset of previous field");
        }
        if (offset !== alignOffset(offset, ty)) {
          throw TypeError("manual offset [" + offset + "] cannot be aligned to `" + ty + "'");
        }
      } else if (field.usePreviousOffset) {
        if ((field.offset = alignOffset(prev.offset, ty)) !== prev.offset) {
          prev.offset = field.offset;
        }
      } else {
        field.offset = alignOffset(prev.offset + prev.type.size, ty);
      }
      if ((s = field.offset + ty.size) > size) {
        size = s;
      }
      prev = field;
    }
    for (_k = 0, _len2 = fields.length; _k < _len2; _k++) {
      field = fields[_k];
      if ((ty = field.type) instanceof PointerType) {
        for (_l = 0, _len3 = fields.length; _l < _len3; _l++) {
          field2 = fields[_l];
          if (field2.offset === field.offset && (ty2 = field2.type) instanceof PointerType) {
            unify(types, ty, ty2, true && unify(types, ty2, ty, true));
          }
        }
      }
    }
    align = maxView.BYTES_PER_ELEMENT;
    this.size = (((size - 1) / align + 1) | 0) * align;
    this.view = maxView;
    return this;
  };

  ArrowType.prototype.lint = function(types) {
    var i, params, ty, _i, _len;
    if (this.linted) {
      return this;
    }
    this.linted = true;
    ty = this.ret.lint(types);
    this.ret = ty;
    params = this.params;
    for (i = _i = 0, _len = params.length; _i < _len; i = ++_i) {
      ty = params[i];
      params[i] = ty.lint(types);
    }
    return this;
  };

  unify = function(types, lty, rty, assign) {
    var i, lpty, lptys, ptys, rptys, _i, _len;
    if (lty === rty) {
      return lty;
    }
    if (!(lty && rty)) {
      return;
    }
    if (lty instanceof PointerType && rty instanceof PointerType) {
      if (assign) {
        if (rty.base && rty.baseAlignment() < lty.baseAlignment()) {
          printWarn("incompatible pointer conversion from `" + rty + "' to `" + lty + "' may alter its value");
        }
        return lty;
      } else {
        if (lty.base === rty.base) {
          return lty;
        }
      }
    }
    if (lty instanceof ArrowType && rty instanceof ArrowType) {
      lptys = lty.params;
      rptys = rty.params;
      if (lptys.length !== rptys.length) {
        return;
      }
      ptys = [];
      for (i = _i = 0, _len = lptys.length; _i < _len; i = ++_i) {
        lpty = lptys[i];
        ptys.push(unify(types, lpty, rptys[i], assign));
      }
      return new ArrowType(ptys, unify(types, lty.ret, rty.ret, assign));
    }
    if (lty instanceof PointerType && __indexOf.call(integral, rty) >= 0) {
      printWarn("conversion from `" + rty + "' to pointer without cast");
      return lty;
    }
    if (__indexOf.call(integral, lty) >= 0 && rty instanceof PointerType) {
      printWarn("conversion from pointer to `" + lty + "' without cast");
      return lty;
    }
    if (__indexOf.call(numeric, lty) >= 0 && __indexOf.call(numeric, rty) >= 0) {
      if (lty.size !== rty.size) {
        printWarn("conversion from `" + rty + "' to `" + lty + "' may alter its value");
        if (assign) {
          return lty;
        } else if (lty.size > rty.size) {
          return lty;
        } else {
          return rty;
        }
      }
      if (lty.signed !== rty.signed) {
        printWarn("conversion from `" + rty + "' to `" + lty + "' may alter its sign");
        return lty;
      }
    }
    return null;
  };

  Op.prototype.isAssignable = Op.prototype.isDeref = function() {
    return !this.second && this.operator === '*';
  };

  Block.prototype.computeType = function(r, o) {
    var exprs;
    exprs = this.expressions;
    if (!(exprs.length > 1)) {
      return;
    }
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    return this.computedType = exprs[exprs.length - 1].unwrapAll().computedType;
  };

  If.prototype.computeType = function(r, o) {
    var elseTy, thenTy, ty, _ref2, _ref3;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    thenTy = (_ref2 = this.body) != null ? _ref2.unwrapAll().computedType : void 0;
    elseTy = (_ref3 = this.elseBody) != null ? _ref3.unwrapAll().computedType : void 0;
    this.computedType = ty = unify(o.types, thenTy, elseTy);
    if ((thenTy || elseTy) && !ty) {
      return printWarn("branches of if have different types: `" + (tystr(thenTy)) + "' and `" + (tystr(elseTy)) + "'");
    }
  };

  Switch.prototype.computeType = function(r, o) {
    var block, caseTys, conds, cty, i, someCaseJumps, someCaseTyped, ty, types, _i, _len, _ref2, _ref3;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    types = o.types;
    caseTys = [];
    someCaseJumps = false;
    someCaseTyped = false;
    _ref2 = this.cases;
    for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {
      _ref3 = _ref2[i], conds = _ref3[0], block = _ref3[1];
      if (block.jumps()) {
        ty = null;
        someCaseJumps = true;
      } else {
        ty = block.unwrapAll().computedType;
      }
      caseTys.push(ty);
      if (ty) {
        someCaseTyped = true;
      }
      if (i === 0) {
        cty = ty;
      } else {
        cty = unify(types, ty, cty);
      }
    }
    if (this.otherwise) {
      cty = unify(types, this.otherwise.unwrapAll().computedType, cty);
    }
    if (someCaseTyped && !cty) {
      if (someCaseJumps) {
        printWarn("cannot type switch with jumps");
      } else {
        printWarn("branches of switch have different types: `" + (((function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = caseTys.length; _j < _len1; _j++) {
            ty = caseTys[_j];
            _results.push(tystr(ty));
          }
          return _results;
        })()).join('\', `')) + "'");
      }
    }
    return this.computedType = cty;
  };

  Cast.prototype.computeType = function(r, o) {
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    return this.computedType = this.type.lint(o.types);
  };

  Literal.prototype.computeType = function(r, o) {
    var _ref2;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    return this.computedType = this.value === 'null' ? anyPtrTy : this.isAssignable() ? (_ref2 = (this.computedBinding = o.scope.binding(this.value))) != null ? _ref2.type : void 0 : this.isSimpleNumber() ? i32ty : !isNaN(Number(this.value)) ? f64ty : void 0;
  };

  Assign.prototype.computeType = function(r, o) {
    var context, lty, msg, rty, value;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    if (!(lty = this.variable.unwrapAll().computedType)) {
      return;
    }
    value = this.value.unwrapAll();
    if (lty instanceof PointerType && value instanceof Literal && value.value === '0') {
      value.computedType = anyPtrTy;
    }
    rty = value.computedType;
    context = this.context;
    this.computedType = context ? binopType(context.substr(0, context.indexOf('=')), lty, rty) : unify(o.types, lty, rty, true);
    if (!this.computedType) {
      msg = "incompatible types: assigning `" + (tystr(rty)) + "' to `" + lty + "'";
      if (context) {
        throw TypeError(msg + (" using " + context));
      } else {
        throw TypeError(msg);
      }
    }
  };

  Value.prototype.computeType = function(r, o) {
    var baseTy, field, fieldName, prop, _i, _len, _ref2;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    if (baseTy = this.base.unwrapAll().computedType) {
      _ref2 = this.properties;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        prop = _ref2[_i];
        if (baseTy instanceof PointerType) {
          baseTy = baseTy.base;
        }
        if (!(baseTy instanceof StructType)) {
          return;
        }
        if (prop.soak) {
          throw TypeError("cannot soak struct field names");
        }
        fieldName = prop.name.unwrapAll().value;
        field = prop.computedField = baseTy.names[fieldName];
        if (!field) {
          throw TypeError("unknown struct field name `" + fieldName + "'");
        }
        baseTy = field.type;
      }
      return this.computedType = baseTy;
    }
  };

  Code.prototype.computeType = function(r, o) {
    var i, rexpr, rty, types, _i, _len, _ref2;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    this.spOffsets = spOffsets(o.scope);
    this.frameSize = o.scope.frameSize;
    types = o.types;
    _ref2 = returnExpressions(this.body);
    for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {
      rexpr = _ref2[i];
      if (i === 0) {
        rty = rexpr.unwrapAll().computedType;
      } else {
        rty = unify(types, rexpr.unwrapAll().computedType, rty);
      }
    }
    return this.computedType = new ArrowType(this.paramTypes, rty);
  };

  Call.prototype.computeType = function(r, o) {
    var args, aty, fty, i, paramTys, pty, types, _i, _len, _ref2, _ref3, _ref4;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    if (!(fty = (_ref2 = this.variable) != null ? _ref2.unwrapAll().computedType : void 0)) {
      return;
    }
    if (!(fty instanceof ArrowType)) {
      throw TypeError("calling a non-function type `" + fty + "'");
    }
    paramTys = fty.params;
    args = this.args;
    types = o.types;
    _ref3 = fty.params;
    for (i = _i = 0, _len = _ref3.length; _i < _len; i = ++_i) {
      pty = _ref3[i];
      aty = (_ref4 = args[i]) != null ? _ref4.computedType : void 0;
      if (pty && !unify(types, pty, aty, true)) {
        throw TypeError("incompatible types: passing arg `" + (tystr(aty)) + "' to param `" + (tystr(pty)) + "'");
      }
    }
    return this.computedType = fty.ret;
  };

  ARITH = ['+', '-', '*', '/'];

  BITWISE = ['<<', '>>', '>>>', '~', '&', '|'];

  COMPARE = ['===', '!==', '<', '>', '<=', '>='];

  binopType = function(op, ty1, ty2) {
    if ((op === '+' || op === '-') && ty1 instanceof PointerType) {
      if (__indexOf.call(integral, ty2) >= 0) {
        return ty1;
      } else if (op === '-' && ty2 instanceof PointerType) {
        if (!unify(o.types, ty1.base, ty2.base)) {
          printWarn("pointer subtraction on incompatible pointer types `" + ty1 + "' and `" + ty2 + "'");
        }
        return i32ty;
      } else {
        throw TypeError("invalid operand type `" + ty2 + "' for pointer arithmetic");
      }
    } else if (op === '%') {
      return i32ty;
    } else if (__indexOf.call(COMPARE, op) >= 0) {
      if (ty1 instanceof PointerType && ty2 instanceof PointerType && !unify(o.types, ty1, ty2)) {
        printWarn("comparison between incompatible pointer types `" + ty1 + "' and `" + ty2 + "'");
      }
      return i32ty;
    } else if (__indexOf.call(BITWISE, op) >= 0) {
      return i32ty;
    } else if (__indexOf.call(ARITH, op) >= 0 && __indexOf.call(numeric, ty1) >= 0 && __indexOf.call(numeric, ty2) >= 0) {
      return f64ty;
    }
  };

  Op.prototype.computeType = function(r, o) {
    var first, name, op, scope, tmp, ty1, ty2;
    if (this.typeCached) {
      return this.computedType;
    }
    this.typeCached = true;
    op = this.operator;
    if (this.isUnary()) {
      first = this.first.unwrapAll();
      return this.computedType = (function() {
        if (op === 'new' && first.value in o.types) {
          ty1 = o.types[first.value];
          if (!(ty1 != null ? ty1.size : void 0)) {
            throw TypeError("cannot allocate unsized type `" + ty1 + "'");
          }
          Scope.root.needsMalloc = true;
          return new PointerType(ty1);
        } else if (op === 'delete' && (ty1 = first.computedType)) {
          if (!(ty1 instanceof PointerType)) {
            throw TypeError('cannot free non-pointer type');
          }
          Scope.root.needsMalloc = true;
          return null;
        } else if (op === 'sizeof') {
          ty1 = this.first = this.first.lint(o.types);
          if (!ty1.size) {
            throw TypeError("cannot determine size of type `" + ty1 + "'");
          }
          return i32ty;
        } else if (op === '&' && (ty1 = first.computedType)) {
          if (!ty1) {
            throw TypeError("taking reference of an untyped expression:\n" + this.first);
          }
          if (ty1 instanceof ArrowType) {
            throw TypeError("taking reference of a function type");
          }
          if (!first.isAssignable()) {
            throw TypeError("taking reference of non-assignable");
          }
          if (first instanceof Literal) {
            name = first.value;
            scope = o.scope;
            if (!scope.check(name, true)) {
              throw TypeError("taking reference of non-local or undefined variable `" + name + "'");
            }
            putOnStack(scope, name);
          }
          return new PointerType(ty1);
        } else if (op === '*' && (ty1 = first.computedType)) {
          if (!ty1) {
            throw TypeError("dereferencing an untyped expression:\n" + this.first);
          }
          if (!(ty1 instanceof PointerType)) {
            throw TypeError("dereferencing a non-pointer type");
          }
          return ty1.base;
        } else if ((op === '++' || op === '--') && (ty1 = first.computedType)) {
          if (ty1 instanceof PointerType || __indexOf.call(integral, ty1) >= 0) {
            return ty1;
          }
        }
      }).call(this);
    }
    ty1 = this.first.unwrapAll().computedType;
    ty2 = this.second.unwrapAll().computedType;
    if (ty2 instanceof PointerType) {
      tmp = ty1;
      ty1 = ty2;
      ty2 = tmp;
    }
    return this.computedType = (function() {
      if ((op === '+' || op === '-') && ty1 instanceof PointerType) {
        if (__indexOf.call(integral, ty2) < 0) {
          throw TypeError("invalid operand type `" + ty2 + "' for pointer arithmetic");
        }
        return ty1;
      } else if (op === '-' && ty1 instanceof PointerType && ty2 instanceof PointerType) {
        if (!unify(o.types, ty1.base, ty2.base)) {
          printWarn("pointer subtraction on incompatible pointer types `" + ty1 + "' and `" + ty2 + "'");
        }
        return i32ty;
      } else if (op === '%') {
        return i32ty;
      } else if (__indexOf.call(COMPARE, op) >= 0) {
        if (ty1 instanceof PointerType && ty2 instanceof PointerType && !unify(o.types, ty1, ty2)) {
          printWarn("comparison between incompatible pointer types `" + ty1 + "' and `" + ty2 + "'");
        }
        return i32ty;
      } else if (__indexOf.call(BITWISE, op) >= 0) {
        return i32ty;
      } else if (__indexOf.call(ARITH, op) >= 0 && __indexOf.call(numeric, ty1) >= 0 && __indexOf.call(numeric, ty2) >= 0) {
        return f64ty;
      }
    })();
  };

  returnExpressions = function(body) {
    var exprs;
    exprs = body.expressions;
    return body.foldChildren([exprs[exprs.length - 1]], 'returnExpression', null, {});
  };

  undefExpr = new Value(new Literal('undefined'));

  Return.prototype.returnExpression = function(exprs, o) {
    exprs.push(this.expression || undefExpr);
    return exprs;
  };

  newTypedScope = function(p, e, m) {
    var scope;
    scope = new Scope(p, e, m);
    scope.variables.length = 0;
    scope.frameSize = 0;
    return scope;
  };

  Assign.prototype.primeComputeType = function(r, o) {
    var fn, name, ty, _ref2;
    if ((fn = this.value.unwrapAll()) instanceof Code && (name = this.variable.unwrapAll()) instanceof Literal && name.isAssignable() && (ty = (_ref2 = o.scope.binding(name.value)) != null ? _ref2.type : void 0) instanceof ArrowType) {
      if (fn.paramTypes == null) {
        fn.paramTypes = ty.params;
      }
      if (fn.returnType == null) {
        fn.returnType = ty.ret;
      }
    }
  };

  Code.prototype.primeComputeType = function(r, o) {
    var i, name, ptys, rexpr, rty, types, _i, _j, _len, _len1, _ref2, _ref3;
    rty = this.returnType;
    if (rty instanceof ArrowType) {
      _ref2 = returnExpressions(this.body);
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        rexpr = _ref2[_i];
        if (!(rexpr instanceof Code)) {
          continue;
        }
        rexpr = rexpr.unwrapAll();
        if (rexpr.paramTypes == null) {
          rexpr.paramTypes = rty.params;
        }
        if (rexpr.returnType == null) {
          rexpr.returnType = rty.ret;
        }
      }
    }
    o.scope = newTypedScope(o.scope, this.body, this);
    ptys = this.paramTypes;
    if (ptys) {
      if (ptys.length !== this.params.length) {
        throw TypeError("arrow type has different number of parameters than function");
      }
      types = o.types;
      _ref3 = this.params;
      for (i = _j = 0, _len1 = _ref3.length; _j < _len1; i = ++_j) {
        name = _ref3[i].name;
        if (!(name instanceof Literal)) {
          throw TypeError("cannot type complex parameter `" + name + "'");
        }
        ptys[i] = ptys[i].lint(types);
        (new DeclareType([new Value(name)], ptys[i])).declareType(r, o);
      }
    }
    this.body.foldChildren(null, 'declareType', null, {
      types: o.types,
      scope: o.scope
    });
  };

  DeclareType.prototype.declareType = function(r, o) {
    var name, scope, type, v, _i, _len, _ref2;
    type = this.type.lint(o.types);
    scope = o.scope;
    _ref2 = this.variables;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      v = _ref2[_i];
      name = v.unwrapAll().value;
      if (scope.check(name)) {
        throw TypeError("cannot redeclare typed variable `" + name + "'");
      }
      scope.add(name, new Binding(type));
      if (type instanceof StructType) {
        putOnStack(scope, name);
      }
    }
  };

  putOnStack = function(scope, name) {
    var bind;
    bind = scope.binding(name, true);
    bind.onStack = true;
    bind.spOffset = alignOffset(scope.frameSize, bind.type);
    scope.frameSize = bind.spOffset + bind.type.size;
  };

  spOffsets = function(scope) {
    var bind, name, offsets, _i, _len, _ref2, _ref3;
    offsets = [];
    _ref2 = scope.variables;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      _ref3 = _ref2[_i], name = _ref3.name, bind = _ref3.type;
      if (bind.onStack) {
        offsets.push({
          name: name,
          offset: bind.spOffset,
          ty: bind.type
        });
      }
    }
    return offsets;
  };

  makeDeref = function(o, base, baseTy, offset, offsetTy) {
    return new Value(offsetTy.view(o), [new Index(offsetExpr(base, baseTy, offset, offsetTy))]);
  };

  inlineMemcpy = function(o, dest, src, ty) {
    var access, assign, destProp, destPtr, field, fty, i, offset, scope, srcProp, srcPtr, stmts, _i, _j, _len, _ref2, _ref3;
    scope = o.scope;
    stmts = [];
    destPtr = new Literal(scope.freeVariable('dest'));
    destPtr.computedType = dest.computedType;
    stmts.push(new Assign(new Value(destPtr), dest));
    srcPtr = new Literal(scope.freeVariable('src'));
    srcPtr.computedType = src.computedType;
    stmts.push(new Assign(new Value(srcPtr), src));
    if (ty instanceof StructType) {
      _ref2 = ty.fields;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        field = _ref2[_i];
        access = new Access(new Literal(field.name));
        access.computedField = field;
        fty = field.type;
        destProp = new Value(destPtr, [access]);
        destProp.computedType = fty;
        srcProp = new Value(srcPtr, [access]);
        srcProp.computedType = fty;
        assign = new Assign(destProp, srcProp);
        assign.computedType = fty;
        stmts.push(assign);
      }
    } else {
      for (i = _j = 0, _ref3 = ty.size; 0 <= _ref3 ? _j < _ref3 : _j > _ref3; i = 0 <= _ref3 ? ++_j : --_j) {
        offset = new Value(new Literal(i));
        stmts.push(new Assign(new Value(U8(o), [new Index(new Op('+', new Value(destPtr), offset))]), new Value(U8(o), [new Index(new Op('+', new Value(srcPtr), offset))])));
      }
    }
    stmts.push(new Value(destPtr));
    return new Value(new Parens(new Block(stmts)));
  };

  structLiteral = function(v, ty, o) {
    var access, field, fname, obj, propList, propValue, ptr, _i, _len, _ref2;
    ptr = new Literal(o.scope.freeVariable('ptr'));
    propList = [];
    _ref2 = ty.fields;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      field = _ref2[_i];
      fname = field.name;
      access = new Access(new Literal(fname));
      access.computedField = field;
      propValue = new Value(ptr, [access]);
      propValue.computedType = field.type;
      propList.push(new Assign(new Value(new Literal(fname)), propValue.transform(), 'object'));
    }
    obj = new Value(new Obj(propList));
    return new Value(new Parens(new Block([new Assign(new Value(ptr), v), obj])));
  };

  stackFence = function(o, exprs, frameSize, spOffsets, isRoot) {
    var name, offset, restoreStack, scope, ty, _i, _len, _ref2;
    U32(o);
    scope = o.scope;
    for (_i = 0, _len = spOffsets.length; _i < _len; _i++) {
      _ref2 = spOffsets[_i], name = _ref2.name, offset = _ref2.offset, ty = _ref2.ty;
      exprs.unshift(new Assign(new Value(new Literal(name)), stackOffsetExpr(offset, ty)));
    }
    exprs.unshift(new Assign(SP, normalizePtr(SPREAL, U32.BYTES_PER_ELEMENT, 1)));
    exprs.unshift(new Assign(SPREAL, new Value(new Literal(frameSize)), '-='));
    restoreStack = new Assign(SPREAL, new Value(new Literal(frameSize)), '+=');
    if (opts.unsafe) {
      if (isRoot) {
        exprs.push(restoreStack);
      }
    } else {
      exprs[0] = new Try(new Block(exprs.slice()), null, null, new Block([restoreStack]));
      exprs.length = 1;
    }
  };

  Cast.prototype.transform = function(r, o) {
    var _base;
    return typeof (_base = this.computedType).coerce === "function" ? _base.coerce(this.expr) : void 0;
  };

  Code.prototype.transform = function(o) {
    var frameSize, _ref2;
    o.returnType = (_ref2 = this.computedType) != null ? _ref2.ret : void 0;
    if (frameSize = this.frameSize) {
      o.frameSize = frameSize;
      stackFence(o, this.body.expressions, frameSize, this.spOffsets);
    }
  };

  Return.prototype.transform = function(o) {
    var body, expr, frameSize, restoreStack, tmp, ty;
    if (ty = o.returnType) {
      this.expression = typeof ty.coerce === "function" ? ty.coerce(this.expression) : void 0;
    }
    if (!((frameSize = o.frameSize) && opts.unsafe)) {
      return;
    }
    restoreStack = new Assign(SPREAL, new Value(new Literal(frameSize)), '+=');
    if (expr = this.expression) {
      tmp = new Value(new Literal(o.scope.freeVariable('t')));
      body = [new Assign(tmp, expr), restoreStack, tmp];
    } else {
      body = [restoreStack, undefExpr];
    }
    this.expression = new Value(new Parens(new Block(body)));
  };

  Call.prototype.transform = function(o) {
    var args, fty, i, paramTys, pty, _i, _len, _ref2, _ref3;
    if (!(fty = (_ref2 = this.variable) != null ? _ref2.unwrapAll().computedType : void 0)) {
      return;
    }
    paramTys = fty.params;
    args = this.args;
    _ref3 = fty.params;
    for (i = _i = 0, _len = _ref3.length; _i < _len; i = ++_i) {
      pty = _ref3[i];
      args[i] = typeof pty.coerce === "function" ? pty.coerce(args[i]) : void 0;
    }
  };

  Literal.prototype.transform = function(o) {
    var ty, _ref2;
    if (!(ty = this.computedType)) {
      return;
    }
    if (this.value === 'null' && ty instanceof PointerType) {
      this.value = '0';
    }
    if (((_ref2 = this.computedBinding) != null ? _ref2.onStack : void 0) && !(ty instanceof StructType) && !this.noStackDeref) {
      return new Value(U32(o), [new Index(new Value(new Literal(this.value)))]);
    }
  };

  Value.prototype.transform = function(o) {
    var base, cumulativeOffset, field, fty, inner, prop, props, v, vty, _i, _len, _ref2;
    if (!this.computedType) {
      return;
    }
    props = this.properties;
    if (!props.length) {
      return;
    }
    base = this.base;
    inner = base.unwrapAll();
    v = (typeof inner.isDeref === "function" ? inner.isDeref() : void 0) ? inner.first : base;
    vty = v.unwrapAll().computedType;
    cumulativeOffset = 0;
    _ref2 = this.properties;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      prop = _ref2[_i];
      field = prop.computedField;
      if ((fty = field.type) instanceof StructType) {
        cumulativeOffset += field.offset;
      } else {
        v = makeDeref(o, v, vty, field.offset + cumulativeOffset, fty);
        vty = fty;
        cumulativeOffset = 0;
      }
    }
    if (fty instanceof StructType && cumulativeOffset !== 0) {
      return new Op('+', v, new Value(new Literal(cumulativeOffset)));
    } else {
      return v;
    }
  };

  Assign.prototype.transform = function(o) {
    var au, lty, lval;
    if (!(lty = this.computedType)) {
      return;
    }
    if (lty instanceof StructType) {
      lval = this.variable.unwrapAll();
      return inlineMemcpy(o, ((typeof lval.isDeref === "function" ? lval.isDeref() : void 0) ? lval.first : this.variable), this.value, lty);
    }
    if (lty instanceof PointerType && this.context && (au = alignmentUnits(lty.base)) !== 1) {
      this.value = new Op('*', this.value, new Value(new Literal(au)));
    } else if (lty.coerce) {
      this.value = lty.coerce(this.value);
    }
  };

  Op.prototype.transform = function(o) {
    var au, op, op1, op2, size, ty1, ty2;
    if (!(this.computedType || this.first.computedType)) {
      return;
    }
    op = this.operator;
    if (this.isUnary()) {
      if (op === 'new' && (ty1 = this.computedType)) {
        return new Call(MALLOC, [new Value(new Literal(ty1.base.size))]);
      } else if (op === 'delete') {
        return new Call(FREE, [this.first]);
      } else if (op === 'sizeof') {
        return new Literal(this.first.size);
      } else if (op === '&' && (ty1 = this.computedType.base)) {
        this.first.unwrapAll().noStackDeref = true;
        return this.first;
      } else if (op === '*') {
        ty1 = this.first.computedType;
        return makeDeref(o, this.first, ty1, 0, ty1);
      } else if ((op === '++' || op === '--') && (ty1 = this.computedType) instanceof PointerType && (au = alignmentUnits(ty1.base)) !== 1) {
        size = new Value(new Literal(au));
        if (op === '++') {
          op1 = '+=';
          op2 = '-';
        } else {
          op1 = '-=';
          op2 = '-';
        }
        return new Value(new Parens(new Block([new Assign(this.first, size, op1), new Op(op2, this.first, size)])));
      }
    } else {
      ty1 = this.first.computedType;
      ty2 = this.second.computedType;
      if ((op === '+' || op === '-') && ((ty1 instanceof PointerType && __indexOf.call(integral, ty2) >= 0 && (au = alignmentUnits(ty1.base)) !== 1) || (ty2 instanceof PointerType && __indexOf.call(integral, ty1) >= 0 && (au = alignmentUnits(ty2.base)) !== 1))) {
        size = new Value(new Literal(au));
        if (ty1 instanceof PointerType) {
          this.second = new Op('*', this.second, size);
        } else {
          this.first = new Op('*', this.first, size);
        }
      } else if (__indexOf.call(COMPARE, op) >= 0 && ty1 instanceof PointerType && ty2 instanceof PointerType) {
        this.second = ty1.coerce(this.second);
      }
    }
  };

  coerceIntegral = function(width, signed) {
    return function(expr) {
      var c, shiftBy, ty;
      ty = expr.unwrapAll().computedType;
      if (ty === this) {
        return expr;
      }
      if (width !== 32 && ty.size << 3 > width) {
        c = new Op('&', expr, new Value(new Literal('0x' + ((1 << width) - 1).toString(16))));
        if (signed) {
          shiftBy = new Value(new Literal(32 - width));
          c = new Op('>>', new Op('<<', c, shiftBy), shiftBy);
        }
        return c;
      } else if (ty.signed !== signed) {
        return new Op((signed ? '|' : '>>>'), expr, new Value(new Literal('0')));
      } else {
        return expr;
      }
    };
  };

  PrimitiveType = (function() {

    function PrimitiveType(size, debugName, view, signed, coerce) {
      this.size = size;
      this.debugName = debugName;
      this.view = view;
      this.signed = signed;
      this.coerce = coerce;
    }

    PrimitiveType.prototype.lint = function(types) {
      return this;
    };

    PrimitiveType.prototype.toString = function() {
      return this.debugName;
    };

    return PrimitiveType;

  })();

  anyPtrTy = new PointerType(null);

  i8ty = new PrimitiveType(1, 'i8', I8, true, coerceIntegral(8, true));

  u8ty = new PrimitiveType(1, 'u8', U8, false, coerceIntegral(8, false));

  i16ty = new PrimitiveType(2, 'i16', I16, true, coerceIntegral(16, true));

  u16ty = new PrimitiveType(2, 'u16', U16, false, coerceIntegral(16, false));

  i32ty = new PrimitiveType(4, 'i32', I32, true, coerceIntegral(32, true));

  u32ty = new PrimitiveType(4, 'u32', U32, false, coerceIntegral(32, false));

  f64ty = new PrimitiveType(8, 'double', F64, true);

  integral = [i8ty, u8ty, i16ty, u16ty, i32ty, u32ty];

  numeric = integral.concat([f64ty]);

  SP.computedType = u32ty;

  SPREAL.computedType = u8ty;

  SPREAL.transform = null;

  requireExpr = function(name) {
    return new Call(new Value(new Literal('require')), [new Value(new Literal("'" + name + "'"))]);
  };

  exports.analyzeTypes = function(root, o) {
    var initialTypes, name, options, scope, ty, types, usesTypes;
    usesTypes = false;
    root.traverseChildren(true, function(node) {
      if (node instanceof DeclareType) {
        usesTypes = true;
        return false;
      }
    });
    if (!usesTypes) {
      return;
    }
    opts.warn = o.warn;
    opts.unsafe = o.unsafe;
    initialTypes = {
      any: null,
      i8: i8ty,
      u8: u8ty,
      i16: i16ty,
      u16: u16ty,
      i32: i32ty,
      u32: u32ty,
      byte: u8ty,
      short: i16ty,
      int: i32ty,
      uint: u32ty,
      double: f64ty,
      num: f64ty
    };
    types = root.foldChildren(initialTypes, 'collectType', null, {
      immediate: true
    });
    for (name in types) {
      ty = types[name];
      if (ty) {
        types[name] = ty.lint(types);
      }
    }
    scope = newTypedScope(null, root, null);
    options = {
      types: types,
      scope: scope
    };
    root.foldChildren(null, 'declareType', null, options);
    options.crossScope = true;
    root.foldChildren(null, 'primeComputeType', 'computeType', options);
    root.spOffsets = spOffsets(scope);
    root.frameSize = scope.frameSize;
    root.transformRoot = function(o) {
      var exprs, frameSize, obj;
      o.scope.assign(HEAP.base.value, "require('heap/heap')");
      exprs = this.expressions;
      if (frameSize = this.frameSize) {
        o.frameSize = frameSize;
        stackFence(o, exprs, frameSize, this.spOffsets, true);
      }
      if (scope.needsMalloc) {
        obj = new Value(new Obj([MALLOC, FREE]));
        return exprs.unshift(new Assign(obj, requireExpr('heap/malloc')));
      }
    };
    return types;
  };

}).call(this);
